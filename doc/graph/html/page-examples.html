<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>proland: Examples</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="page-examples">Examples </a></h1> 
<div class="mainpage">
<h2><a class="anchor" id="sec-graph1">
Graph1 example</a></h2>
 
<img src="graph1.png"><br/>
 <!--  <div align="center">
<img src="graph1.png" alt="graph1.png"/>
</div>
  --> <p>This example is based on the "terrain3" example of the terrain plugin, with two modifications: the fractal terrain is replaced with a precomputed one, with a precomputed texture as well, and a road graph is used, via layers, to modify the terrain shape and texture procedurally (based on the paper "Real-time 
rendering and editing of vector-based terrains", Eric Bruneton and Fabrice Neyret, Eurographics 2008).</p>
<h3><a class="anchor" id="sec-graph1-terrain">
Precomputed terrain</a></h3>
<p>The replacement of the fractal terrain with a precomputed one is done as in the "terrain4" example (see sec-terrain4-res), and is not detailled here. The replacement of the procedural texture with a precomputed one is also very similar: we first define an ortho CPU producer to load the tiles from disk to main memory (in a tile cache on CPU):</p>
 <div class="fragment"><pre class="fragment">    &lt;tileCache name=<span class="stringliteral">&quot;groundOrthoCpu&quot;</span> scheduler=<span class="stringliteral">&quot;defaultScheduler&quot;</span>&gt;
        &lt;cpuByteTileStorage tileSize=<span class="stringliteral">&quot;196&quot;</span> channels=<span class="stringliteral">&quot;4&quot;</span> capacity=<span class="stringliteral">&quot;1024&quot;</span>/&gt;
    &lt;/tileCache&gt;
    &lt;orthoCpuProducer name=<span class="stringliteral">&quot;groundOrthoCpu1&quot;</span> cache=<span class="stringliteral">&quot;groundOrthoCpu&quot;</span> file=<span class="stringliteral">&quot;RGB.dat&quot;</span>/&gt;
</pre></div></p>
<p>We can then reference this CPU producer from the OrthoGPUProducer:</p>
<p><div class="fragment"><pre class="fragment">    &lt;orthoGpuProducer name=<span class="stringliteral">&quot;groundOrthoGpu1&quot;</span> ortho=<span class="stringliteral">&quot;groundOrthoCpu1&quot;</span>
</pre></div></p>
<h3><a class="anchor" id="sec-graph1-layers">
Graph based elevation and texture layers</a></h3>
<p>In order to define layers based on vector data we first need a graph producer, which will produce graph tiles by clipping and flattening a root graph. We also need a tile cache to store the produced graph tiles on CPU. This is done as follows:</p>
 <div class="fragment"><pre class="fragment">    &lt;tileCache name=<span class="stringliteral">&quot;graphCache&quot;</span> scheduler=<span class="stringliteral">&quot;defaultScheduler&quot;</span>&gt;
        &lt;objectTileStorage capacity=<span class="stringliteral">&quot;2048&quot;</span>/&gt;
    &lt;/tileCache&gt;

    &lt;basicGraphFactory name=<span class="stringliteral">&quot;graphFactory&quot;</span>/&gt;
    &lt;graphProducer name=<span class="stringliteral">&quot;roads&quot;</span> cache=<span class="stringliteral">&quot;graphCache&quot;</span> factory=<span class="stringliteral">&quot;graphFactory&quot;</span>
        file=<span class="stringliteral">&quot;roads&quot;</span> doFlatten=<span class="stringliteral">&quot;true&quot;</span>/&gt;
</pre></div></p>
<p>This defines a cache that can store up to 2048 graph tiles, and a graph producer using this cache, and using as root graph the "roads.graph" file. The graph factory specifies which kind of graph implementation we want (lazy or not, hydro graph or not, etc).</p>
<p>Adding a layer using this graph to the ortho GPU producer, in order to draw roads on the terrain, is then very easy:</p>
<p><div class="fragment"><pre class="fragment">    &lt;orthoGpuProducer name=<span class="stringliteral">&quot;groundOrthoGpu1&quot;</span> ortho=<span class="stringliteral">&quot;groundOrthoCpu1&quot;</span>
            cache=<span class="stringliteral">&quot;groundOrthoGpu&quot;</span> backgroundCache=<span class="stringliteral">&quot;groundOrthoGpu&quot;</span>&gt;
        &lt;roadOrthoLayer name=<span class="stringliteral">&quot;roadOrtho1&quot;</span> graph=<span class="stringliteral">&quot;roads&quot;</span>
            renderProg=<span class="stringliteral">&quot;roadLayerOrthoShader;&quot;</span> quality=<span class="stringliteral">&quot;true&quot;</span>/&gt;
    &lt;/orthoGpuProducer&gt;
</pre></div></p>
<p>We simply need to declare a <a class="el" href="classproland_1_1RoadOrthoLayer.html" title="An OrthoGPUProducer layer to draw roads.">proland::RoadOrthoLayer</a> layer as a sub-element of the producer declaration, with a reference to the previous graph producer, and to the shader that will effectively draw the roads in the texture (see below). Note that we also need to add a "backgroundCache" attribute in the ortho GPU producer itself. This is necessary when layers are used with a precomputed texture (this cache may be different from the "cache" one).</p>
<p>Adding a layer using the above graph producer to the elevation producer, in order to deform the terrain where there are roads, is a little more complex. Indeed the <a class="el" href="classproland_1_1RoadElevationLayer.html" title="An ElevationGraphLayer for road graphs.">proland::RoadElevationLayer</a> needs a producer, on CPU, that can compute the raw terrain elevations, as the elevation producer does on GPU (it needs it to compute road elevation profiles). This is the role of the proland::CPUElevationProducer, which is declared as follows:</p>
 <div class="fragment"><pre class="fragment">    &lt;tileCache name=<span class="stringliteral">&quot;groundElevationsCPU&quot;</span> scheduler=<span class="stringliteral">&quot;defaultScheduler&quot;</span>&gt;
        &lt;cpuFloatTileStorage tileSize=<span class="stringliteral">&quot;101&quot;</span> channels =<span class="stringliteral">&quot;1&quot;</span> capacity=<span class="stringliteral">&quot;1024&quot;</span>/&gt;
    &lt;/tileCache&gt;
    &lt;cpuElevationProducer name=<span class="stringliteral">&quot;groundElevations2&quot;</span> cache=<span class="stringliteral">&quot;groundElevationsCPU&quot;</span>
        residuals=<span class="stringliteral">&quot;groundResiduals1&quot;</span>/&gt;
</pre></div></p>
<p>Note that we only need one channel per pixel, and that the tile size must be the same as the one used by the GPU elevation producer. We can then declare a <a class="el" href="classproland_1_1RoadElevationLayer.html" title="An ElevationGraphLayer for road graphs.">proland::RoadElevationLayer</a> in the elevation producer on GPU:</p>
<p><div class="fragment"><pre class="fragment">    &lt;elevationProducer name=<span class="stringliteral">&quot;groundElevations1&quot;</span> cache=<span class="stringliteral">&quot;groundElevations&quot;</span>
            residuals=<span class="stringliteral">&quot;groundResiduals1&quot;</span>&gt;
        &lt;roadElevationLayer name=<span class="stringliteral">&quot;roadElevation1&quot;</span> graph=<span class="stringliteral">&quot;roads&quot;</span>
            cpuElevations=<span class="stringliteral">&quot;groundElevations2&quot;</span> renderProg=<span class="stringliteral">&quot;roadLayerElevationShader;&quot;</span> level=<span class="stringliteral">&quot;2&quot;</span>/&gt;
    &lt;/elevationProducer&gt;
</pre></div></p>
<p>Here we specify two producers for this layer, the one producing the graph, "roads", and the one producing the raw elevations on CPU, "groundElevations2". We also specify the shader that will actually modify the terrain elevations, "roadLayerElevationShader" (see below). Finally the "level" attribute specifies that this layer must not be used for quadtree levels less than 2.</p>
<p>The "roadLayerOrthoShader.glsl" shader is used to draw triangle strips covering roads, with a uv parameteriztion along the strips. The vertex shader simply scales and translates the input vertices with the given "tileOffset". The fragment shader computes a color and an alpha mask, which will then be blended into the raw terrain texture. In this implementation this shader computes roads stripes procedurally, but you can easily change this (as an exercise: try to add an "asphalt" texture to roads - hint: look at the "texturedPlastic.xml" and "texturedPlastic.glsl" files in the Ork examples). Note that you can change this shader will the program is running, to immediately see the effects of your changes on the appearance of roads.</p>
<p>The "roadLayerElevationShader.glsl" is similar. In addition to the vertex coordinates it also takes as parameter, in the "uv" vertex attribute, the vertex elevation and its distance to the road axis (relatively to the road width). It must output the road elevation in the blue channel, an alpha value, and a fragment depth (to ensure that crossing roads blend nicely). The current implementation is very basic but you can easily change it, including while the program is running (to immediately see the effects of your changes on the appearance of roads).</p>
<p>The output road elevations and alpha coefficients are then blended into the raw terrain elevations with the "blendShader.glsl" shader (you can specify another name with the "blendProg" attribute in the elevation producer resource). </p>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Sat May 12 09:42:45 2012 for proland by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
