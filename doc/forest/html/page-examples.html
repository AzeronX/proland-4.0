<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>proland: Examples</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="page-examples">Examples </a></h1> 
<div class="mainpage">
<h2><a class="anchor" id="sec-trees1">
Trees1 example</a></h2>
 
<img src="trees1.png"><br/>
 <!--  <div align="center">
<img src="trees1.png" alt="trees1.png"/>
</div>
  --> <p>This example adds billboard trees to the "terrain3" example.</p>
<h3><a class="anchor" id="sec-trees1-lcc">
Lcc map</a></h3>
<p>The first step to add such trees is to provide a tree density map, so that trees will be instantiated only where this density is not null. For this we define a tile cache to store the tiles of this density map (we call it a "land cover classification" map, or LCC map, because it contains in general more than one density - although here we use only one):</p>
 <div class="fragment"><pre class="fragment">    &lt;tileCache name=<span class="stringliteral">&quot;groundLccGpu&quot;</span> scheduler=<span class="stringliteral">&quot;defaultScheduler&quot;</span>&gt;
        &lt;gpuTileStorage tileSize=<span class="stringliteral">&quot;100&quot;</span> nTiles=<span class="stringliteral">&quot;512&quot;</span>
            internalformat=<span class="stringliteral">&quot;R8&quot;</span> format=<span class="stringliteral">&quot;RED&quot;</span> type=<span class="stringliteral">&quot;UNSIGNED_BYTE&quot;</span> min=<span class="stringliteral">&quot;LINEAR&quot;</span> mag=<span class="stringliteral">&quot;LINEAR&quot;</span>/&gt;
    &lt;/tileCache&gt;
</pre></div></p>
<p>Here we specify that our LCC tiles are 100x100 pixels (including borders), and have 1 channel per pixel. We can then define an ortho producer to produce these LCC tiles. Here we want a fractal noise, modified based on the local terrain elevation and slope, in order to avoid planting trees in the oceans or in cliffs. For this we use an ortho producer (to produce the raw noise) with two layers (one to exclude ocean areas, the other to exclude cliffs - note that we said earlier that an ortho producer cannot have layers: in fact this is possible in practice, but generally does not give meaningful results. Here is an exception that proves the rule):</p>
 <div class="fragment"><pre class="fragment">    &lt;orthoProducer name=<span class="stringliteral">&quot;groundLccGpu1&quot;</span> cache=<span class="stringliteral">&quot;groundLccGpu&quot;</span> maxLevel=<span class="stringliteral">&quot;7&quot;</span>
        upsampleProg=<span class="stringliteral">&quot;upsampleLccShader;&quot;</span> cnoise=<span class="stringliteral">&quot;127.5,0,0,0&quot;</span>
        noise=<span class="stringliteral">&quot;0,255,255,255,255,255,255,255&quot;</span>&gt;
        &lt;textureLayer name=<span class="stringliteral">&quot;slopeFilter1&quot;</span> producer=<span class="stringliteral">&quot;groundNormals1&quot;</span>
            renderProg=<span class="stringliteral">&quot;slopeFilter;&quot;</span> tileSamplerName=<span class="stringliteral">&quot;fragmentNormalSampler&quot;</span>/&gt;
        &lt;textureLayer name=<span class="stringliteral">&quot;elevationFilter1&quot;</span> producer=<span class="stringliteral">&quot;groundElevations1&quot;</span>
            renderProg=<span class="stringliteral">&quot;elevationFilter;&quot;</span> tileSamplerName=<span class="stringliteral">&quot;elevationSampler&quot;</span>/&gt;
    &lt;/orthoProducer&gt;
</pre></div></p>
<p>The raw ortho producer is defined in a similar way as in the "terrain3" example, except that we use a slightly different upsample and add shader. The first layer modifies the raw densities generated by this producer, based on the normal tiles produced by the "groundNormals1" producer, and used via the "fragmentNormalSampler" uniform in the "slopeFilter" shader. This shader computes a color and an alpha mask, based on these normals, which is then blended in the raw density map (here no blending mode is specified in the layer definition, so the default mode is used - ADD with SRC_ALPHA and ONE_MINUS_SRC_ALPHA):</p>
 <div class="fragment"><pre class="fragment">uniform samplerTile fragmentNormalSampler;

in vec2 st;
layout(location=0) out vec4 data;

<span class="keywordtype">void</span> main() {
    vec2 lNormal = textureTile(fragmentNormalSampler, st).xy * 2.0 - 1.0;
    <span class="keywordtype">float</span> z = sqrt(1.0 - dot(lNormal, lNormal));
    data = vec4(0.0, 0.0, 0.0, 1.0 - smoothstep(0.85, 0.9, z));
}
</pre></div></p>
<p>Here the output color is black (i.e., density 0) and the alpha mask is one when the slope is high. The result, after blending, is that the tree density is set to 0 in areas where the slope is high. The second layer is similar, and sets the tree density to zero when the altitude is less than 4:</p>
 <div class="fragment"><pre class="fragment">uniform samplerTile elevationSampler;

in vec2 st;
layout(location=0) out vec4 data;

<span class="keywordtype">void</span> main() {
    <span class="keywordtype">float</span> z = textureTile(elevationSampler, st).z;
    data = vec4(0.0, 0.0, 0.0, 1.0 - smoothstep(4.0, 5.0, z));
}
</pre></div></p>
<h3><a class="anchor" id="sec-trees1-plants">
Trees specification</a></h3>
<p>Once we have a tree density map, the next step is to specify how we want to instantiate trees based on this map. This is done as follows:</p>
 <div class="fragment"><pre class="fragment">    &lt;plants name=<span class="stringliteral">&quot;trees&quot;</span>
        selectProg=<span class="stringliteral">&quot;selectTreeShader;&quot;</span>
        renderProg=<span class="stringliteral">&quot;renderTreeShader;&quot;</span>
        minLevel=<span class="stringliteral">&quot;5&quot;</span> maxLevel=<span class="stringliteral">&quot;7&quot;</span> maxDistance=<span class="stringliteral">&quot;5000.0&quot;</span> tileCacheSize=<span class="stringliteral">&quot;400&quot;</span>
        minDensity=<span class="stringliteral">&quot;8500&quot;</span> maxDensity=<span class="stringliteral">&quot;8500&quot;</span> patternCount=<span class="stringliteral">&quot;10&quot;</span>&gt;
    &lt;/plants&gt;
</pre></div></p>
<p>This specifies that trees will be instantiated for terrain quads whose level in the quadtree is between 5 and 7, that no trees will be visible at a distance more than 5000, and that for each terrain quad at level 7, 8500 trees will be instantiated (4 times more for quads at level 6, and 16 times more at level 5 - the maximum number of instantiated trees will be 400x8500=3400000). For each quad at level 7 a random point pattern will be used to instantiate the trees, chosen at random amongst 10 precomputed patterns.</p>
<p>The "selectProg" program is responsible to remove some points from these patterns, in order to generate the desired tree density (based on the LCC map produced above). It is also responsible to generate some attributes for these points, based on random seeds associated with each point, and optionally on external maps (color, elevation, normal, etc). For instance a very important attribute is the tree altitude, which can be generated by sampling an elevation tile (see below).</p>
<p>Finally the "renderProg" program will be responsible to generate camera facing quads from these points, and to texture and shade them (it is also possible to specify a "shadowProg" in order to render the trees in cascaded shadow maps, in order to simulate the shadows of trees, but we do not use it here).</p>
<p>The "selectProg" shader receives as input a point pattern, where each point has xy coordinates in the [0,1] range, and a z coordinate encoding four random bytes. It may discard some points, and must output for the remaining points at most two vec3 values. In this example the "selectTreeShader" outputs a xyz position on the terrain for each point, in a first vec3, as well as the terrain normal, a random color, a random size, and a random value, packed in a second vec3:</p>
 <div class="fragment"><pre class="fragment">in vec3 pt[];
out vec3 pos;
out vec3 params;

<span class="keywordtype">void</span> main()
{
    <span class="keywordflow">if</span> (textureTile(lccSampler, pt[0].xy).r &gt; 0.25) {
        <span class="keywordtype">float</span> z = textureTile(elevationSampler, pt[0].xy).z - 0.35;
        vec2 n = textureTile(fragmentNormalSampler, pt[0].xy).xy;
        pos = vec3(pt[0].xy * tileOffset.z + tileOffset.xy, z);
        vec4 seeds = unpackUnorm4x8(floatBitsToUint(pt[0].z));
        vec3 color = vec3(1.0) + (seeds.rgb - vec3(0.5)) * vec3(0.45, 0.45, 0.75);
        <span class="keywordtype">float</span> size = mix(0.8, 1.2, seeds.w) * 0.5;
        <span class="keywordtype">float</span> seed = dot(seeds, vec4(0.25));
        params = vec3(uintBitsToFloat(packUnorm2x16(n)),
                    uintBitsToFloat(packUnorm4x8(vec4(color, size))),
                    uintBitsToFloat(packUnorm4x8(vec4(seed, 0.0, 0.0, 0.0))));
        EmitVertex();
        EndPrimitive();
    }
}
</pre></div></p>
<p>This code discards the input point pt if the tree density at this point, given by lccSampler, is less than 0.25. For the remaining points, the terrain height and normal are read from the elevationSampler and fragmentNormalSampler tile samplers, the random bytes are extracted from the z coordinate of pt, and the tree position and attributes are computed and output in "pos" and "params". Note that, in order for these outputs to be stored in a VBO for use during rendering, you must enable transform feedback for them:</p>
 <div class="fragment"><pre class="fragment">    &lt;module name=<span class="stringliteral">&quot;selectTreeShader&quot;</span> version=<span class="stringliteral">&quot;400&quot;</span> source=<span class="stringliteral">&quot;selectTreeShader.glsl&quot;</span>
        feedback=<span class="stringliteral">&quot;interleaved&quot;</span> varyings=<span class="stringliteral">&quot;pos,params&quot;</span>/&gt;
</pre></div></p>
<p>During rendering the "renderTreeShader.glsl" reads these points, discards those outside the view frustum based on the "clip" uniforms set by <a class="el" href="classproland_1_1DrawPlantsTask.html" title="TODO.">proland::DrawPlantsTask</a>, and generates a camera facing quad for the others (using the size attribute generated by the previous shader). It then shades these quads by using the random color, and the terrain normal stored for each tree by the previous shader.</p>
<h3><a class="anchor" id="sec-trees1-node">
Trees scene node</a></h3>
<p>Finally, in order to generate and draw the trees, it is necessary to add a scene node for them in the scene graph:</p>
 <div class="fragment"><pre class="fragment">        &lt;node name=<span class="stringliteral">&quot;plants&quot;</span> flags=<span class="stringliteral">&quot;object,shadow&quot;</span>&gt;
            &lt;bounds xmin=<span class="stringliteral">&quot;-50000&quot;</span> xmax=<span class="stringliteral">&quot;50000&quot;</span> ymin=<span class="stringliteral">&quot;-50000&quot;</span> ymax=<span class="stringliteral">&quot;50000&quot;</span> zmin=<span class="stringliteral">&quot;0&quot;</span> zmax=<span class="stringliteral">&quot;5000&quot;</span>/&gt;
            &lt;field <span class="keywordtype">id</span>=<span class="stringliteral">&quot;terrain&quot;</span> value=<span class="stringliteral">&quot;terrainNode&quot;</span>/&gt;
            &lt;method <span class="keywordtype">id</span>=<span class="stringliteral">&quot;draw&quot;</span> value=<span class="stringliteral">&quot;drawPlantsMethod&quot;</span>/&gt;
            &lt;method <span class="keywordtype">id</span>=<span class="stringliteral">&quot;shadow&quot;</span> value=<span class="stringliteral">&quot;drawPlantsShadowMethod&quot;</span>/&gt;
        &lt;/node&gt;
</pre></div></p>
<p>Here we specify two methods. The "shadow" method is the following:</p>
<div class="fragment"><pre class="fragment">&lt;?xml version=<span class="stringliteral">&quot;1.0&quot;</span> ?&gt;
&lt;drawPlantsShadow name=<span class="stringliteral">&quot;terrain&quot;</span> plants=<span class="stringliteral">&quot;trees&quot;</span>/&gt;
</pre></div><p>It generates the trees for the newly created terrain quads at each frame. It also renders the trees in cascaded shadow maps, if a "shadow" prog is specified in the "trees" resource. This method must be called after the terrain quadtree is updated, but before the trees are rendered. For this we add a loop in the camera method, over all objects having the "shadow" flag (which is the case of the above scene node), between the update and draw loops:</p>
 <div class="fragment"><pre class="fragment">    &lt;sequence name=<span class="stringliteral">&quot;cameraMethod&quot;</span>&gt;
        &lt;<span class="keywordflow">foreach</span> var=<span class="stringliteral">&quot;o&quot;</span> flag=<span class="stringliteral">&quot;dynamic&quot;</span> parallel=<span class="stringliteral">&quot;true&quot;</span>&gt;
            &lt;callMethod name=<span class="stringliteral">&quot;$o.update&quot;</span>/&gt;
        &lt;/<span class="keywordflow">foreach</span>&gt;
        &lt;<span class="keywordflow">foreach</span> var=<span class="stringliteral">&quot;l&quot;</span> flag=<span class="stringliteral">&quot;shadow&quot;</span>&gt;
            &lt;callMethod name=<span class="stringliteral">&quot;$l.shadow&quot;</span>/&gt;
        &lt;/<span class="keywordflow">foreach</span>&gt;
        &lt;<span class="keywordflow">foreach</span> var=<span class="stringliteral">&quot;o&quot;</span> flag=<span class="stringliteral">&quot;object&quot;</span> culling=<span class="stringliteral">&quot;true&quot;</span>&gt;
            &lt;callMethod name=<span class="stringliteral">&quot;$o.draw&quot;</span>/&gt;
        &lt;/<span class="keywordflow">foreach</span>&gt;
        &lt;<span class="keywordflow">foreach</span> var=<span class="stringliteral">&quot;o&quot;</span> flag=<span class="stringliteral">&quot;overlay&quot;</span>&gt;
            &lt;callMethod name=<span class="stringliteral">&quot;$o.draw&quot;</span>/&gt;
        &lt;/<span class="keywordflow">foreach</span>&gt;
    &lt;/sequence&gt;
</pre></div></p>
<p>The "draw" method is the following:</p>
<div class="fragment"><pre class="fragment">&lt;?xml version=<span class="stringliteral">&quot;1.0&quot;</span> ?&gt;
&lt;drawPlants name=<span class="stringliteral">&quot;terrain&quot;</span> plants=<span class="stringliteral">&quot;trees&quot;</span>/&gt;
</pre></div><dl class="note"><dt><b>Note:</b></dt><dd>both methods expects the scene node to contain a "terrain" field, specifying on which terrain scene node the trees must be instantiated. If this scene node has a tile sampler whose name is "elevation", "fnormal" or "lcc", then the corresponding GLSL uniform will be set in the "selectProg" above, so that it can use this external data to generate attributes for each tree. </dd></dl>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Sat May 12 09:42:31 2012 for proland by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
