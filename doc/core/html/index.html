<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>proland: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li class="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1></h1> 
<div class="mainpage">
<br/><h1>Proland Documentation - Core Library</h1>
<h2><a class="anchor" id="sec-intro">
Introduction</a></h2>
<p><b>Proland</b> is a <b>pro</b>cedural <b>land</b>scape rendering library. It is designed to render in real-time very large landscapes, up to whole planets. In this context it is not possible to store in GPU memory the whole landscape data. Instead this data must be <em>produced</em> on the fly for the current view. This can be done by loading precomputed data from disk, or by generating it with procedural methods. Another goal of Proland is the real-time editing of landscapes. This is realized by regenerating the landscape data on the fly, in the same way it is generated on the fly when the viewer moves.</p>
<p>Proland is made of a <em>core</em> library, extended by several <em>plugins</em>. The core library provides a <em>producer framework</em>, a <em>terrain framework</em>, and a basic <em>user interface</em> framework. </p>
<ul>
<li>
<p class="startli">The producer framework defines a common interface for all data producers, such as CPU or GPU producers, raster data or vector data producers, etc. Producers can use other producers to produce their data and can then be composed in complex ways (for instance a terrain normal producer can produce normals from the elevations produced by an elevation producer). The producer framework also provides a generic cache component to store produced data. This is used to take advantage of the temporal coherence: thanks to this cache, a data produced for one frame can be reused for the subsequent frames. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The <em>terrain framework</em> uses a terrain quadtree that is dynamically subdivided, based on the current viewer position. It also provides a new GLSL uniform type that can be used to access a cache of raster data on GPU, and some methods to update these caches (by using data producers) and to draw a terrain. It also provides <em>deformations</em> to map a flat terrain to other shapes, such as spheres (to render planets). </p>
<p class="endli"></p>
</li>
<li>
the user interface framework is based on EventHandlers. It provides the basics for navigating through the large scenes that you can display in Proland.  </li>
</ul>
<p>The Proland plugins provide several <em>predefined producers</em> based on this framework: some producers are dedicated to the production of terrain elevation data, others are designed to produce generic raster data (this data can represent anything you want, such as reflectances, land cover classes, normal maps, horizon maps, ambient occlusion maps, etc), and others produce vector data (it is also possible to produce raster data from vector data, by rasterizing the vector data into textures).</p>
<p>Proland is based on the Ork library in several ways: </p>
<ul>
<li>
<p class="startli">the producer framework uses Ork tasks to produce data. Hence the landscape data can be produced in parallel, or even ahead of time with the prefetching feature of the Ork scheduling framework. This framework also provides the dependencies between producer tasks. Hence when a data produced by a producer is edited, all the data derived directly or indirectly from it, via other producers, is also automatically recomputed.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">the terrain framework uses the Ork rendering framework for shaders, meshes, etc. and extends the Ork scene graph with new methods to update GPU caches and to draw terrains.</p>
<p class="endli"></p>
</li>
<li>
finally Proland extends the Ork resource framework with new resource types for the predefined producers and for the terrain components. </li>
</ul>
<p>The following sections present the producer framework, the terrain framework and the user interface framework:</p>
<ul>
<li>
<a class="el" href="index.html#sec-producerframework">Producer framework</a> <ul>
<li>
<a class="el" href="index.html#sec-storage">Tile storage</a> </li>
<li>
<a class="el" href="index.html#sec-cache">Tile cache</a> </li>
<li>
<a class="el" href="index.html#sec-producer">Tile producer</a> </li>
<li>
<a class="el" href="index.html#sec-userproducer">User defined producers</a> </li>
</ul>
</li>
<li>
<a class="el" href="index.html#sec-terrain">Terrain framework</a> <ul>
<li>
<a class="el" href="index.html#sec-deform">Terrain deformation</a> </li>
<li>
<a class="el" href="index.html#sec-quad">Terrain quadtree</a> </li>
<li>
<a class="el" href="index.html#sec-uniforms">Texture tile samplers</a> </li>
<li>
<a class="el" href="index.html#sec-tasks">Terrain tasks</a> </li>
</ul>
</li>
<li>
<a class="el" href="index.html#sec-ui">User Interface</a> <ul>
<li>
<a class="el" href="index.html#sec-defaulthandlers">Default Handlers</a> </li>
<li>
<a class="el" href="index.html#sec-twbars">TweakBars</a> </li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="sec-producerframework">
Producer framework</a></h2>
<p>The producer framework defines how the landscape data is produced, stored and cached. Using this framework it is possible to define several producers, each producer producing a part of the landscape data. For instance there can be a producer for the terrain elevation, another for the terrain normals, a producer for the terrain reflectance, another for the river data, a producer for building models, etc. Each producer can use as input procedural parameters, data stored on disk, data produced by another producer, a combination of these, etc.</p>
<p>The producer framework assumes that the data produced by a producer is divided in a <em>quadtree</em>. This means that each <em>tile</em>, i.e., the data associated with a <em>quad</em>, can be produced independently. A tile can contain raster data, vector data, or any other data. Each producer can organize its data using its own quadtree, i.e., the quadtrees of the various producers need not have the same characteristics (maximum depth, tile size, etc). However the quads and tiles are always identified using the same "coordinate
system", whatever their quadtree. In fact a quad or tile is identified by its <em>level</em> in the quadtree (0 is the root), and by its <em>tx,ty</em> coordinates at this level (<em>tx</em> and <em>ty</em> varying between 0 and 2<sup><em>level</em></sup>-1 with 0,0 being the lower left corner). These <em>(level,tx,ty)</em> coordinates are called <em>logical coordinates</em>:</p>
 
<center>
<embed src="logicalcoords.svg" width="80%" type="image/svg+xml"/>
<br/>
<div class="caption">Logical quad and tile coordinates <i>
(level,tx,ty)</i></div>
</center>
 <!--  <div align="center">
<img src="logicalcoords.svg" alt="logicalcoords.svg"/>
</div>
  --> <p>The root tile (0,0,0) of a producer contains the data corresponding to the whole landscape, at a coarse resolution. The tiles at the other levels contain only a part of the data, but at higher resolution (the higher the level, the higher the resolution). The producer framework also uses <em>physical coordinates</em>. These coordinates are the <em>ox,oy</em> coordinates of the lower left corner of a <em>quad</em> in a fixed reference frame, whose origin is at the center of the root quad, plus the size of the quad <em>l</em> in some length unit (e.g., meters). The figure below illustrates this, assuming that the size of the root quad is <em>L</em>:</p>
 
<center>
<embed src="physicalcoords.svg" width="80%" type="image/svg+xml"/>
<br/>
<div class="caption">Physical quad coordinates <i>(ox,oy,l)</i></div>
</center>
 <!--  <div align="center">
<img src="physicalcoords.svg" alt="physicalcoords.svg"/>
</div>
  --> <p>These physical coordinates are only <em>local</em> coordinates, like the local reference frame of each scene node in an Ork scene graph. At rendering time the landscape can be placed anywhere in the world frame with appropriate translations, rotations and other transformations.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>there is a clear distinction between a quad and a tile. A quad is a node in a quadtree, a tile is some data associated with a quad. Logical coordinates apply to both quads and tiles, but physical coordinates are only associated with quads. In fact a tile can contain data outside the physical boundary of its associated quad. In this case we say that the tile has a non empty <em>border</em>. Tiles with borders introduce some redundancy in the produced data, but this redundancy is sometimes useful to avoid artifacts with texture filtering, to avoid producing neighboring tiles, etc. The figure below illustrates this difference with tiles containing raster data.</dd></dl>
 
<center>
<embed src="tileborder.svg" width="80%" type="image/svg+xml"/><br/>
<div class="caption">Difference between tiles and quads. <i>Left</i>:
tiles without borders correspond exactly to quads. <i>Right</i>:
tiles with borders introduce some redundancy.</div>
</center>
 <!--  <div align="center">
<img src="tileborder.svg" alt="tileborder.svg"/>
</div>
  --> <p>Tiles are stored in <em>tile storages</em>. There are tile storages for raster data tiles on GPU (using textures), tile storages for raster data on CPU (using arrays), and tile storages for vector data or other CPU data (using ork::Object). It is also possible to define tile storages on GPU using GPU buffers, for instance vertex buffers (for instance the PlantsProducer produces one point mesh for each quad, with all these meshes stored in a single GPU buffer - see the source code of proland::PlantsProducer).</p>
<p>A tile storage can contain tiles produced by several producers. In other words several producers can use the same storage to store their tiles. A tile storage can contain tiles that are necessary for the current view, but it can also contain tiles that were created for a previous frame but are no longer used. If the viewer goes back to the previous viewpoint, then these tiles will be reused directly: they will not need to be produced again. Similarly a tile storage can contain tiles that are prefetched, i.e., that are produced ahead of time for future frames.</p>
<p>The knowledge of which tiles are <em>in use</em>, i.e., necessary for the current view, and which are not (cached from a previous frame, or prefetched for a future frame), is managed by a <em>tile cache</em>. A tile cache also stores a mapping between the logical coordinates of tiles, and their <em>storage coordinates</em>, i.e., their location in the tile storage. Like tile storages, tile caches can be shared between tile producers. The figure below illustrates the relation between a tile cache and a tile storage, using a GPU tile storage (the storage coordinates format and meaning depend on the kind of storage used. For a GPUTileStorage using textures, it is a layer index - the storage texture is a 2DArrayTexture, with one tile per layer).</p>
 
<center>
<embed src="producerframework.svg" width="80%" type="image/svg+xml"/>
<br/>
<div class="caption">Relation between tile caches and tile
storages.</div>
</center>
 <!--  <div align="center">
<img src="producerframework.svg" alt="producerframework.svg"/>
</div>
  --> <p>In this example, the tile cache indicates that the tiles (2,1,2) and (2,1,3) are in use, and are stored in the tile storage, in the layers 3 and 1. It also indicates that 3 other tiles are available in the tile storage but are currently unused, i.e., not necessary for the current view. The tile storage stores the tiles in a 2D texture array with 7 layers. Each layer is a 8x8 2D texture, also called a <em>slot</em>. Currently only 5 slots are <em>allocated</em>, the remaining slots are <em>free</em> to store other tiles. Note that an allocated slot (at the storage level) can correspond to an unused tile or to a tile in use (at the cache level).</p>
<h3><a class="anchor" id="sec-storage">
Tile storage</a></h3>
<p>A tile storage is represented with the <a class="el" href="classproland_1_1TileStorage.html" title="A shared storage to store tiles of the same kind.">proland::TileStorage</a> class. This abstract class has 3 sub classes <a class="el" href="classproland_1_1GPUTileStorage.html" title="A TileStorage that stores tiles in 2D array textures.">proland::GPUTileStorage</a>, <a class="el" href="classproland_1_1CPUTileStorage.html" title="A TileStorage that store tiles on CPU.">proland::CPUTileStorage</a> and <a class="el" href="classproland_1_1ObjectTileStorage.html" title="A TileStorage that stores Object on CPU.">proland::ObjectTileStorage</a>, for GPU raster data, CPU raster data, and CPU vector or other data (respectively - you can also implement your own subclass, see for instance the source code of proland::PlantsProducer, which defines a GPU tile storage based on a vertex buffer object). Each tile storage has a <em>capacity</em> which is the number of <em>slots</em> in this storage, each slot being able to store one tile. The capacity of a storage is fixed and cannot be changed at runtime. Each slot can either be <em>free</em> or <em>allocated</em>. A free slot does not contain any tile, an allocated slot contain a single tile (either in use or not).</p>
<p>The capacity can be retrieved with <a class="el" href="classproland_1_1TileStorage.html#a0aa5e4a3848c0f09f6f98711b9dca00a" title="Returns the total number of slots managed by this TileStorage.">proland::TileStorage::getCapacity</a>. The number of free slots is given by <a class="el" href="classproland_1_1TileStorage.html#a90b30b7b43b4065e248cce4a20507a94" title="Returns the number of slots in this TileStorage that are currently unused.">proland::TileStorage::getFreeSlots</a>. A free slot can be obtained with <a class="el" href="classproland_1_1TileStorage.html#a8ed89ef3b03b98fe1d7df604c9e4df81" title="Returns a free slot in the pool of slots managed by this TileStorage.">proland::TileStorage::newSlot</a>. The returned slot is then considered allocated, and can be used to store a tile. Conversely an allocated slot can be returned to the pool of free slots with <a class="el" href="classproland_1_1TileStorage.html#ae4d9f9c24f5eed9465e2a6e36081689b" title="Notifies this storage that the given slot is free.">proland::TileStorage::deleteSlot</a>.</p>
<h4><a class="anchor" id="sec-gpustorage">
GPUTileStorage</a></h4>
<p>The <a class="el" href="classproland_1_1GPUTileStorage.html" title="A TileStorage that stores tiles in 2D array textures.">proland::GPUTileStorage</a> is a tile storage to store raster data tiles on GPU. It uses 2D textures or 2D array textures to store the tiles. Such a tile storage can be created with the Ork resource framework, using the following format:</p>
<div class="fragment"><pre class="fragment">
&lt;?xml version="1.0" ?&gt;
&lt;gpuTileStorage name="myGpuStorage"
    tileSize="196" nTiles="512"
    internalformat="RGBA8" format="RGBA" type="UNSIGNED_BYTE"
    min="LINEAR_MIPMAP_LINEAR" mag="LINEAR" minLOD="0" maxLOD="1"
    tileMap="false"/&gt;
</pre></div><p>In this example each slot is created to store tiles made of 196x196 pixels (this size must include the tile borders, if any). The total number of slots is 512. In other words this storage allocates a 196x196x512 2D array texture. This texture uses the RGBA8 internal format (this gives a total of 71.2 MB). The texture filters and min and max LOD are specified like for texture resources. The <code>tileMap</code> attribute in explained in the <a class="el" href="index.html#sec-tilemap">terrain framework</a> section.</p>
<p>The slots managed by a GPU tile storage are described with the <a class="el" href="classproland_1_1GPUTileStorage_1_1GPUSlot.html" title="A slot managed by a GPUTileStorage.">proland::GPUTileStorage::GPUSlot</a> class. This class describes the location of the slot in the storage textures. It also provides methods to copy a part of the framebuffer or of a texture into this slot.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If you use a mipmap filter, then each time the content of a slot is changed you must call <a class="el" href="classproland_1_1GPUTileStorage.html#a9d958479f3f83cef41b3d5fd99d8a4de" title="Notifies this manager that the content of the given slot has changed.">proland::GPUTileStorage::notifyChange</a> (this is used to automatically update the mipmap levels of the storage textures when changes have occurred). In fact you don't have to do this yourself, unless you write your own producer.</dd></dl>
<h4><a class="anchor" id="sec-cpustorage">
CPUTileStorage</a></h4>
<p>The <a class="el" href="classproland_1_1CPUTileStorage.html" title="A TileStorage that store tiles on CPU.">proland::CPUTileStorage</a> is a tile storage to store raster data tiles on CPU. It uses arrays to store the tiles (each tile is stored in its own array). Such a tile storage can be created with the Ork resource framework, using the following format:</p>
<div class="fragment"><pre class="fragment">
&lt;?xml version="1.0" ?&gt;
&lt;cpuByteTileStorage name="myCpuStorage"
    tileSize="196" channels="4" capacity="1024"/&gt;
</pre></div><p>In this example the storage can store 1024 tiles made of 196x196 pixels, with 4 bytes per pixel. Using <code>cpuFloatTileStorage</code> instead, the pixels would have been made of 4 <em>floats</em> per pixels.</p>
<p>The slots managed by a CPU tile storage are described with the <a class="el" href="classproland_1_1CPUTileStorage_1_1CPUSlot.html" title="A slot managed by a CPUTileStorage.">proland::CPUTileStorage::CPUSlot</a> class. This class gives access to the array containing the tile raster data.</p>
<h4><a class="anchor" id="ObjectTileStorage">
ObjectTileStorage</a></h4>
<p>The <a class="el" href="classproland_1_1ObjectTileStorage.html" title="A TileStorage that stores Object on CPU.">proland::ObjectTileStorage</a> is a tile storage to store arbitrary data tiles on CPU. Each slot stores a pointer to an ork::Object. Unlike the GPU and CPU tile storages, here the data for each slot is not allocated by the tile storage (since it can be arbitrary). Instead, you must allocate this data manually each time you get new slot, and you must delete it manually each time you delete a slot. Such a tile storage can be created with the Ork resource framework, using the following format:</p>
<div class="fragment"><pre class="fragment">
&lt;?xml version="1.0" ?&gt;
&lt;objectTileStorage name="myObjectStorage" capacity="1024"/&gt;
</pre></div><p>The slots managed by an object tile storage are described with the <a class="el" href="classproland_1_1ObjectTileStorage_1_1ObjectSlot.html" title="A tile managed by an ObjectTileStorage.">proland::ObjectTileStorage::ObjectSlot</a> class. This class gives access to the tile data via a pointer.</p>
<h3><a class="anchor" id="sec-cache">
Tile cache</a></h3>
<p>A tile cache is represented with the <a class="el" href="classproland_1_1TileCache.html" title="A cache of tiles to avoid recomputing recently produced tiles.">proland::TileCache</a> class. Since a tile cache does not store tiles itself (this is done by tile storages), but only stores and manages a mapping between logical tile coordinates and slots in a tile storage, a single class can be used for all kinds of tiles.</p>
<p>A tile cache has an associated tile storage. It manages a mapping between logical tile coordinates and slots in its associated storage. A tile cache is used by one or more tile producers. Each time a tile producer is created and associated with a tile cache, it gets a local <em>producer id</em> from the tile cache, and the tile cache maintains a reference to this producer. This reference is used when a new tile from this producer is requested from the cache, in order to produce it.</p>
<p>The tiles managed by a tile cache can be in use or not (tiles in use generally correspond to those that are necessary to render the current landscape view). More precisely a tile cache keeps track of the number of users of each tile. Users acquire tiles with the <a class="el" href="classproland_1_1TileCache.html#a14e66219b3fa0391a7e2015d9a6dc594" title="Returns the requested tile, creating it if necessary.">proland::TileCache::getTile</a> method, and release them with <a class="el" href="classproland_1_1TileCache.html#ae3c6986a83c7d71b2ab67f2e6259b7fb" title="Decrements the number of users of this tile by one.">proland::TileCache::putTile</a>. Hence the first method increments the counter of users of the requested tile, and the second method decrements this counter. When this counter becomes 0 the tile becomes unused.</p>
<p>A tile in use is "locked", i.e., its slot in the tile storage cannot be reused to store another tile, as long as the tile is in use. On the contrary, a unused tile can be <em>evicted</em> from the cache at any moment, and its slot can be reused to store another tile. This happens, in particular, when a new used tile is needed, but all slots in the storage are allocated. Then it is necessary to evict an unused tile from the cache, in order to reuse its slot to store the new used tile. An evicted tile will need to be produced again if it is needed again in the future. In order to minimize the number of times a tile is regenerated, a tile cache evicts in priority the tiles that have not been used since a long time (this heuristic is called the Least Recently Used - or LRU - cache heuristic).</p>
<p>In addition to <a class="el" href="classproland_1_1TileCache.html#a14e66219b3fa0391a7e2015d9a6dc594">getTile</a> and <a class="el" href="classproland_1_1TileCache.html#ae3c6986a83c7d71b2ab67f2e6259b7fb">putTile</a>, the main methods of a tile cache are the following: </p>
<ul>
<li>
<p class="startli">the <a class="el" href="classproland_1_1TileCache.html#ad3c0723651bf4d027502ce401cac3a82" title="Looks for a tile in this TileCache.">proland::TileCache::findTile</a> method can be used to find a tile in the cache. This method does not change the number of users of the returned tile. The tile can be looked for in the list of tiles that are in use, or in all the tiles managed by the tile cache, whether they are used or not.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">the <a class="el" href="classproland_1_1TileCache.html#ae84e6971f4c52572a7c68472bbc58d61" title="Returns a prefetch task to create the given tile.">proland::TileCache::prefetchTile</a> method is used to request the production of a tile for the future frames. The method returns immediately. The tile will be created as an unused tile. If there is no free slot to store this prefetched tile, an unused tile will be evicted first.</p>
<p class="endli"></p>
</li>
<li>
the <a class="el" href="classproland_1_1TileCache.html#a6724ba66d1f0922eae91f5625f9bffaf" title="Invalidates the tiles from this cache produced by the given producer.">proland::TileCache::invalidateTiles</a> method is used to force the regeneration of the tiles produced by a given producer. All the tiles keep their current slot in the tile storage, but the slot content will be recomputed before use (this means that tiles in use will be recomputed immediately, while unused tiles will not be recomputed before they become in use again). </li>
</ul>
<p>When a tile is requested with <a class="el" href="classproland_1_1TileCache.html#a14e66219b3fa0391a7e2015d9a6dc594">getTile</a> two cases can happen: </p>
<ul>
<li>
<p class="startli">if the tile is in cache its number of users is incremented by one. If the tile was unused it becomes in use.</p>
<p class="endli"></p>
</li>
<li>
otherwise the tile is produced, in a free storage slot or in the slot of a previously evicted (and unused) tile. In fact the tile is not produced immediately. Instead a ork::Task to produce the tile is returned (inside a <a class="el" href="classproland_1_1TileCache_1_1Tile.html" title="A tile described by its level,tx,ty coordinates.">proland::TileCache::Tile</a>). This task needs to be executed by a ork::Scheduler before the tile data can be used. </li>
</ul>
<h4><a class="anchor" id="sec-restilecache">
TileCache resource</a></h4>
<p>A tile cache can be loaded with the Ork resource framework, using the following format (the nested storage resource can of course be a <code> cpuXxxTileStorage</code> or an <code>objectTileStorage</code>; it describes the tile storage associated with the tile cache):</p>
<div class="fragment"><pre class="fragment">
&lt;?xml version="1.0" ?&gt;
&lt;tileCache name="myCache" scheduler="myScheduler"&gt;
    &lt;gpuTileStorage .../&gt;
&lt;/tileCache&gt;
</pre></div><h3><a class="anchor" id="sec-producer">
Tile producer</a></h3>
<p>A tile producer is represented with the <a class="el" href="classproland_1_1TileProducer.html" title="An abstract producer of tiles.">proland::TileProducer</a> class. This abstract class has many concrete sub classes, presented in the sec-producers section. A tile producer has an associated tile cache, used to cache the tiles it produces (it is given by <a class="el" href="classproland_1_1TileProducer.html#afa38fddd5b785e941fcdaaa37e43cdcc" title="Returns the TileCache that stores the tiles produced by this producer.">proland::TileProducer::getCache</a>). A tile producer is associated with a single cache, but a cache can be used by several producers (if they produce tiles of the same type). In order to distinguish tiles produced by different producers in a tile cache, each producer has a unique local identifier in this cache, automatically assigned when the producer is created. It is given by <a class="el" href="classproland_1_1TileProducer.html#a3f80c42e6ef622730ebf0b35f37db909" title="Returns the id of this producer.">proland::TileProducer::getId</a>.</p>
<p>The main method of a tile producer is the <a class="el" href="classproland_1_1TileProducer.html#a15611db1a548547fe37ebfddee6f43f3" title="Creates the given tile.">proland::TileProducer::doCreateTile</a> abstract method. It implements the tile production algorithm, i.e., it defines how the tiles are produced. However this method is never called directly, but through the <a class="el" href="classproland_1_1TileProducer.html#adf72006cc497a5f13fe0dc3a7251879c" title="Returns the requested tile, creating it if necessary.">proland::TileProducer::getTile</a> method. If a requested tile is not in the cache, <a class="el" href="classproland_1_1TileProducer.html#adf72006cc497a5f13fe0dc3a7251879c">getTile</a> does <em>not</em> produce this tile immediately. Instead a ork::Task to produce this tile is returned.</p>
<p>A "basic" tile producer returns a "basic" ork::Task to produce a tile, i.e. a task without dependencies on other tasks. On the contrary, a tile producer that uses as input data tiles produced by another producer returns a ork::TaskGraph to produce a tile. This task graph contains the task to produce the tile, with dependencies to the task(s) that produce the input data. Consider for example a normal producer, producing terrain normals from terrain elevations produced by an elevation producer. We then have the following producers, caches and storages:</p>
 
<center>
<embed src="producerchain.svg" width="80%" type="image/svg+xml"/>
<br/>
<div class="caption">A producer using as input tiles produced by
another producer.</div>
</center>
 <!--  <div align="center">
<img src="producerchain.svg" alt="producerchain.svg"/>
</div>
  --> <p>Then the task graphs returned by the <a class="el" href="classproland_1_1TileProducer.html#adf72006cc497a5f13fe0dc3a7251879c">getTile</a> method of the normal producer look like this:</p>
 
<center>
<embed src="producerchaingraph.svg" width="80%"
type="image/svg+xml"/><br/>
<div class="caption">The task graph to produce the tiles of a
producer that uses another producer.</div>
</center>
 <!--  <div align="center">
<img src="producerchaingraph.svg" alt="producerchaingraph.svg"/>
</div>
  --> <p>The task N(2,1,2) to produce the normal tile (2,1,2) has a dependency towards the task E(2,1,2) that produces the elevations for the same quad, and both are put in a task graph.</p>
<p>In practice the elevation producer is not a "basic" producer: it uses as input data tiles produced by a residual producer (see sec-producers). It also <em>uses itself recursively</em>: in fact an elevation tile is produced from its <em>parent</em> elevation tile, by upsampling its data and adding to it residual elevations. An elevation producer may also use vector data produced by a graph producer (via <em>layers</em> - see below), which also uses itself recursively. So in fact we have the following relations between the normal, elevation, residual and graph producers (here we do not show the associated caches and storages):</p>
 
<center>
<embed src="producerchain2.svg" width="80%" type="image/svg+xml"/>
<br/>
<div class="caption">Relation between the normal, elevation, residual
and graph producers.</div>
</center>
 <!--  <div align="center">
<img src="producerchain2.svg" alt="producerchain2.svg"/>
</div>
  --> <p>The task N(2,1,2) to produce the normal tile (2,1,2) is then a more complex task graph (in reality the graph is even more complex, because a normal producer also uses itself recursively, like the elevation and graph producers):</p>
 
<center>
<embed src="producerchain2graph.svg" width="80%"
type="image/svg+xml"/><br/>
<div class="caption">Task graph for the normal tile N(2,1,2).</div>
</center>
 <!--  <div align="center">
<img src="producerchain2graph.svg" alt="producerchain2graph.svg"/>
</div>
  --> <p>At the highest level we still have a task graph with two nested tasks N(2,1,2) and E(2,1,2), with a dependency between them, as in the previous example. Here however the E(2,1,2) task is itself a task graph. Note the "fractal" aspect of the whole graph: this comes from the recursive use of the elevation producer by itself, and of the graph producer by itself. Note also that this double recursion leads to tasks that appear in several task graphs, i.e., that are shared between task graphs (there is only one instance of each shared task).</p>
<p>Successive calls to the <a class="el" href="classproland_1_1TileProducer.html#adf72006cc497a5f13fe0dc3a7251879c">getTile</a> method <em>for the same tile</em>, always return the <em>same</em> ork::Task instance. Since a task instance is executed only once (see Task graph), the complex task graph above, once scheduled, will generally not lead to the execution of all the tasks it contains. Indeed most tasks will probably have already been executed, and so will not be reexecuted. However, if any task in this graph is explicitly rescheduled (this happens if the corresponding tile is invalidated with <a class="el" href="classproland_1_1TileProducer.html#ac0baa67cf52a32c0f24f03a9461b0e96" title="Invalidates the tiles produced by this producer.">proland::TileProducer::invalidateTiles</a>), the Ork framework will automatically reschedule the tasks that depend directly or indirectly on the rescheduled task. Hence all the tiles depending directly or indirectly on the invalidated tile will be automatically recomputed.</p>
<h4><a class="anchor" id="sec-producerapi">
Main methods</a></h4>
<p>The <a class="el" href="classproland_1_1TileProducer.html" title="An abstract producer of tiles.">proland::TileProducer</a> class provides some generic methods that provide information about the tiles it can produce: </p>
<ul>
<li>
<p class="startli">the <a class="el" href="classproland_1_1TileProducer.html#a57ef81d271cff94555850738f75ffb50" title="Returns true if this producer produces textures on GPU.">proland::TileProducer::isGpuProducer</a> indicates whether this producer produces raster data tiles on GPU or not. A GPU producer is supposed to use a tile cache associated with a <a class="el" href="classproland_1_1GPUTileStorage.html" title="A TileStorage that stores tiles in 2D array textures.">proland::GPUTileStorage</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">the <a class="el" href="classproland_1_1TileProducer.html#abfad2424cfeddf05c3ad62408175e526" title="Returns the size in meters of the root quad produced by this producer.">proland::TileProducer::getRootQuadSize</a> gives the physical size of the root quad of the quadtree managed by this producer. This size can be set with <a class="el" href="classproland_1_1TileProducer.html#ab946c1b6c1d057048e9d5743113bf572" title="Sets the size in meters of the root quad produced by this producer.">proland::TileProducer::setRootQuadSize</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">the <a class="el" href="classproland_1_1TileProducer.html#a21f1ca539b2bdb145898d6c5f61b0ed6" title="Returns the size in pixels of the border of each tile.">proland::TileProducer::getBorder</a> method indicates if the tiles produced by this producer have a border. More precisely it indicates the size of these borders, in pixels (assuming that tiles contain raster data). The default implementation of this method returns 0 (i.e., no border), but you can override it.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">the <a class="el" href="classproland_1_1TileProducer.html#a6d6d78b50379d88ed614902a8f70b837" title="Returns true if this producer can produce the given tile.">proland::TileProducer::hasTile</a> method indicates if this producer can produce a tile, specified by its logical coordinates. By default this method returns always <code>true</code>, but you can override it. For instance, it is common for producers to be limited to a maximum resolution, i.e., to a maximum level in the quadtree.</p>
<p class="endli"></p>
</li>
<li>
the <a class="el" href="classproland_1_1TileProducer.html#a2d2a79606cd9939a0360f628832d7cd4" title="Returns true if this producer can produce the children of the given tile.">proland::TileProducer::hasChildren</a> method indicates if this producer can produce the sub tiles of a tile, specified by its logical coordinates. The producer framework assumes that if a sub tile of a tile can be produced, then the four sub tiles of this tile can be produced. Hence this method returns <code>true</code> if the lower left sub tile of the specified tile can be produced (as returned by <a class="el" href="classproland_1_1TileProducer.html#a6d6d78b50379d88ed614902a8f70b837">hasTile</a>). </li>
</ul>
<p>There is also a <a class="el" href="classproland_1_1TileProducer.html#aa951fc73faf28097774e2ddeb9306e30" title="Updates the tiles produced by this producer, if necessary.">proland::TileProducer::update</a> method, which is called once per frame (via <a class="el" href="classproland_1_1UpdateTileSamplersTask.html" title="An AbstractTask to update the TileSampler associated with a terrain.">proland::UpdateTileSamplersTask</a> and <a class="el" href="classproland_1_1TileSampler.html#a73f40642cbc7482afa3b25ff2523bd80" title="Returns the task graph necessary to create new texture tiles for newly created quads...">proland::TileSampler::update</a>). This method does nothing by default, but you can override it to invalidate the tiles if necessary (i.e., if some input data used to produce the tiles has changed - if this input data is produced by another producer then you don't need to do this, it will be done automatically via the Ork tasks framework). Alternatively, if the produced data must be animated, you can also modify, via this method, the content of already produced tiles at each frame.</p>
<p>Finally the <a class="el" href="classproland_1_1TileProducer.html" title="An abstract producer of tiles.">proland::TileProducer</a> class also provides some convenient methods that simply call the corresponding methods on its associated tile cache. These methods are: </p>
<ul>
<li>
<a class="el" href="classproland_1_1TileProducer.html#adf72006cc497a5f13fe0dc3a7251879c" title="Returns the requested tile, creating it if necessary.">proland::TileProducer::getTile</a> </li>
<li>
<a class="el" href="classproland_1_1TileProducer.html#ac9371d0fda7c4a8314378ca438871a5b" title="Decrements the number of users of this tile by one.">proland::TileProducer::putTile</a> </li>
<li>
<a class="el" href="classproland_1_1TileProducer.html#af6a7253ba9180d042cd07bbfe2ff622b" title="Looks for a tile in the TileCache of this TileProducer.">proland::TileProducer::findTile</a> </li>
<li>
<a class="el" href="classproland_1_1TileProducer.html#a26096fefa49dad630a9bb809b9f8ddbb" title="Schedules a prefetch task to create the given tile.">proland::TileProducer::prefetchTile</a> </li>
<li>
<a class="el" href="classproland_1_1TileProducer.html#ac0baa67cf52a32c0f24f03a9461b0e96" title="Invalidates the tiles produced by this producer.">proland::TileProducer::invalidateTiles</a> </li>
</ul>
<h4><a class="anchor" id="sec-producerlayer">
Tile producer layers</a></h4>
<p>Some tile producers can be customized with <em>layers</em>. A layer can modify the data produced by the "raw" producer or by the previous layers. For instance you can imagine a layer to draw roads from vector data on top of a satellite photo (the "raw" data), or a layer to modify the terrain elevations, based on the same road vector data, to generate the footprint of roads in the terrain. Like a producer, a layer can use as input data produced by other producers (in the previous example, the layers use vector data produced by a graph producer). The layers of a tile producer are managed with the <a class="el" href="classproland_1_1TileProducer.html#a52c2a90a268c0717befa05a34b27af36" title="Returns the number of layers of this producer.">proland::TileProducer::getLayerCount</a>, <a class="el" href="classproland_1_1TileProducer.html#a8b6a235c5fbb039579e02272c7cdc7c9" title="Returns the layer of this producer whose index is given.">proland::TileProducer::getLayer</a> and <a class="el" href="classproland_1_1TileProducer.html#aeddcca35ca49c9cbcf69f66a08c6e08d" title="Adds a Layer to this producer.">proland::TileProducer::addLayer</a> methods.</p>
<h3><a class="anchor" id="sec-userproducer">
User defined producers</a></h3>
<p>You can define your own tile producers by extending the <a class="el" href="classproland_1_1TileProducer.html" title="An abstract producer of tiles.">proland::TileProducer</a> class. This section shows how you can do this, using the example of a GPU producer using as input tiles produced by a CPU producer.</p>
<p><div class="fragment"><pre class="fragment"><span class="keyword">class </span>MyProducer : <span class="keyword">public</span> TileProducer
{

<span class="keyword">public</span>:
    MyProducer(Ptr&lt;TileCache&gt; cache, Ptr&lt;TileProducer&gt; input, ...) :
        TileProducer(<span class="stringliteral">&quot;MyProducer&quot;</span>, <span class="stringliteral">&quot;MyCreateTile&quot;</span>)
    {
        init(cache, input, ...);
    }

    <span class="keyword">virtual</span> ~MyProducer()
    {
    }


<span class="keyword">protected</span>:
    MyProducer() : TileProducer(<span class="stringliteral">&quot;MyProducer&quot;</span>, <span class="stringliteral">&quot;MyCreateTile&quot;</span>)
    {
    }

    <span class="keywordtype">void</span> init(Ptr&lt;TileCache&gt; cache, Ptr&lt;TileProducer&gt; input, ...)
    {
        TileProducer::init(cache, <span class="keyword">true</span>);
        this-&gt;input = input;
        ...
    }
</pre></div></p>
<p>The above code contains the initialization code to create our producer, using the pattern to easily define an Ork resource subclass of this class (see User defined resources). The constructor takes as argument a tile cache, that will be used to cache the produced tiles. This argument is required by the constructor of the super class. The constructor also takes as argument the producer whose tiles will be used as input. We assume it is a CPU producer.</p>
<p><div class="fragment"><pre class="fragment">
    <span class="keyword">virtual</span> Ptr&lt;Task&gt; startCreateTile(<span class="keywordtype">int</span> level, <span class="keywordtype">int</span> tx, <span class="keywordtype">int</span> ty,
        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> deadline, Ptr&lt;Task&gt; task, Ptr&lt;TaskGraph&gt; owner)
    {
        Ptr&lt;TaskGraph&gt; result = owner == NULL ? <span class="keyword">new</span> TaskGraph(task) : owner;
        TileCache::Tile *t = input-&gt;getTile(level, tx, ty, deadline);
        result-&gt;addTask(t-&gt;task);
        result-&gt;addDependency(task, t-&gt;task);
        <span class="keywordflow">return</span> result;
    }
</pre></div></p>
<p>The <code>startCreateTile</code> method overrides the corresponding method of the super class. Its role is to construct the task or graph of tasks to produce a given tile. Here our producer use as input a tile produced by another producer, so the "basic" task to produce our tile - automatically constructed and passed as argument in <code>task</code> - must have a dependency on this input task (so that it is executed before we start producing our tile). This is why this method creates a task graph containing <code>task</code>, as well as the task <code>t</code> to produce the input. Its then adds these tasks in a task graph, and creates a dependency between them. Note that <code>t</code> is obtained with a <code>getTile</code>: this will lock this input tile until we call <code>putTile</code>, i.e., the input data will not be evicted from the cache unexpectedly.</p>
<p><div class="fragment"><pre class="fragment">
    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> doCreateTile(<span class="keywordtype">int</span> level, <span class="keywordtype">int</span> tx, <span class="keywordtype">int</span> ty, TileStorage::Slot *data)
    {
        CPUTileStorage&lt;unsigned char&gt;::CPUSlot *in;
        GPUTileStorage::GPUSlot *out;
        TileCache::Tile *t = intput-&gt;findTile(level, tx, ty);
        in = <span class="keyword">dynamic_cast&lt;</span>CPUTileStorage&lt;unsigned char&gt;::CPUSlot*<span class="keyword">&gt;</span>(t-&gt;getData());
        out = <span class="keyword">dynamic_cast&lt;</span>GPUTileStorage::GPUSlot*<span class="keyword">&gt;</span>(data);
        ...
        getCache()-&gt;getStorage().cast&lt;GPUTileStorage&gt;()-&gt;notifyChange(out);
    }
</pre></div></p>
<p>The <code>doCreateTile</code> method overrides the corresponding method of the super class. Its role is to generate the requested tile. Here this method first gets the input tile needed for this production. Note that is does so with <code>findTile</code>: we are sure the tile is in cache because it can not be evicted until we call <code>putTile</code> (see above). It then gets the slot in which the tile must be produced. This slot is passed as argument in <code>data</code> but must be cast to the right type. Once the tile is produced (by the "dots"), the producer notifies its tile storage that the slot in which the tile has been produced has changed, so the mipmap levels of the storage textures can be automatically updated when needed (see <a class="el" href="index.html#sec-gpustorage">GPUTileStorage</a>).</p>
<p><div class="fragment"><pre class="fragment">
    <span class="keyword">virtual</span> <span class="keywordtype">void</span> stopCreateTile(<span class="keywordtype">int</span> level, <span class="keywordtype">int</span> tx, <span class="keywordtype">int</span> ty)
    {
        TileCache::Tile *t = input-&gt;findTile(level, tx, ty);
        input-&gt;putTile(t);
    }

<span class="keyword">private</span>:
    Ptr&lt;TileProducer&gt; input;
};
</pre></div></p>
<p>The <code>stopCreateTile</code> method overrides the corresponding method of the super class. Its role is to clean up the "resources" used during the tile production. Here this method calls <code>putTile</code> on the tile used as input, since the content of this tile is no longer necessary. The effect of this call is to unlock this input tile (if it was not locked by other users), which can then be evicted from its cache at any moment.</p>
<h4><a class="anchor" id="sec-userlayer">
User defined tile producer layers</a></h4>
<p>You can also define your own tile producer layers by extending the <a class="el" href="classproland_1_1TileLayer.html" title="An abstract layer for a TileProducer.">proland::TileLayer</a> class. This task is very similar with the definition of a tile producer. In particular a tile producer layer has the same <code>startCreateTile</code>, <code>doCreateTile</code> and <code>stopCreateTile</code> methods, which have the same role and can be overridden in the same way.</p>
<h2><a class="anchor" id="sec-terrain">
Terrain framework</a></h2>
<p>The terrain rendering framework manages one or more terrains, each terrain being associated with a set of tile producers. For each terrain, the terrain quadtree is dynamically subdivided, based on the current viewer position. When new quads are subdivided, the producers associated with the terrain are used to produce the corresponding tiles. The terrain framework also provides new GLSL uniforms that allow shaders to access the slots of a texture cache like a normal texture. Hence you can access the produced tiles like normal textures in your shaders. Finally the framework provides <em>deformations</em> to map a flat terrain to other shapes, such as spheres (to render planets).</p>
<dl class="note"><dt><b>Note:</b></dt><dd>here we speak about "terrains" but in fact the framework is not limited to the terrain itself. Indeed the tile producers associated with a terrain can produce any kind of data, including data to render 3D vegetation or buildings on top of the terrain (see the "trees1" example). Hence the "terrain" framework can be used to render full landscapes.</dd></dl>
<h3><a class="anchor" id="sec-deform">
Terrain deformation</a></h3>
<p>The terrain framework supports <em>terrain deformations</em>. A deformation here is not a local terrain modification. Instead, it is a <em>global</em> deformation of <em>space</em>, which can for instance transform a plane into a sphere or a cylinder. Terrain deformations are used to generate spherical planets, cylindrical terrains (e.g., for a cylindrical space ship whose rotation simulates gravity), etc.</p>
<p>A deformation transforms a point in a <em>local space</em> into a point in a <em>deformed space</em>:</p>
 
<center>
<embed src="deformation.svg" width="80%" type="image/svg+xml"/><br/>
<div class="caption">Notations for terrain deformations.</div>
</center>
 <!--  <div align="center">
<img src="deformation.svg" alt="deformation.svg"/>
</div>
  --> <p>In practice the local space is the space in which the quad physical coordinates are defined - see <a class="el" href="index.html#sec-producerframework">Producer framework</a>. In the local space the "sea level" surface is the plane z=0, z being the vertical axis. This plane can be deformed into a sphere, a cylinder, etc. Note however that a deformation transforms the whole 3D space, not a single 2D surface (this is needed to transform points above the sea level).</p>
<p>The <a class="el" href="classproland_1_1Deformation.html" title="A deformation of space.">proland::Deformation</a> class represents a terrain deformation. It defines the methods that a terrain deformation must provide, and implements them for the case of the identity deformation (i.e., no deformation). The <a class="el" href="classproland_1_1SphericalDeformation.html" title="A Deformation of space transforming planes to spheres.">proland::SphericalDeformation</a> is a sub class of this class that deforms horizontal planes into spheres. Finally the <a class="el" href="classproland_1_1CylindricalDeformation.html" title="A Deformation of space transforming planes to cylinders.">proland::CylindricalDeformation</a> is a sub class of this class that deforms horizontal planes into cylinders. Note that you can define your own sub classes if needed.</p>
<p>The actual deformation is implemented by the following methods: </p>
<ul>
<li>
<p class="startli"><a class="el" href="classproland_1_1Deformation.html#a0c5a0589af749362711fbe2f1636f791" title="Returns the deformed point corresponding to the given source point.">proland::Deformation::localToDeformed</a>: transforms a point in the local space into the deformed space.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="el" href="classproland_1_1Deformation.html#ae1630455997991f9f771263e6e4c5755" title="Returns the local point corresponding to the given source point.">proland::Deformation::deformedToLocal</a>: transforms a point in the deformed space into the local space.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="el" href="classproland_1_1Deformation.html#a9132264a8a424bff58336e6296527612" title="Returns the differential of the deformation function at the given local point.">proland::Deformation::localToDeformedDifferential</a>: computes the differential of the deformation function at some local point. This differential gives a linear approximation of the deformation around a point: if p is near localPt, then the deformed point corresponding to p can be approximated with <code> localToDeformedDifferential</code>(localPt) * (p - localPt).</p>
<p class="endli"></p>
</li>
<li>
<a class="el" href="classproland_1_1Deformation.html#acea0b459634ded8edc5eb3bcee149011" title="Returns an orthonormal reference frame of the tangent space at the given deformed...">proland::Deformation::deformedToTangentFrame</a>: computes an orthonormal reference frame of the tangent space at a deformed point. This reference frame is such that its xy plane is the tangent plane, at deformedPt, to the deformed surface corresponding to the local plane z=<em>cste</em>. This orthonormal reference frame does <em> not</em> give the differential of the inverse deformation function, which in general is not an orthonormal transformation. This tangent frame defines the tangent space in which terrain normals are computed. </li>
</ul>
<p>The <a class="el" href="classproland_1_1Deformation.html" title="A deformation of space.">proland::Deformation</a> class is also responsible to set the GLSL shader uniforms that are necessary to transform the terrain vertices on GPU. This is done with the <a class="el" href="classproland_1_1Deformation.html#ac80fb697439f19614899fe84e0ff5bae" title="Sets the shader uniforms that are necessary to project on screen the TerrainQuad...">proland::Deformation::setUniforms</a> methods. There are two such methods: the first one can set uniforms that do not depend on a quad (such as a sphere radius for a spherical deformation), while the other can set uniforms that are specific to a quad. The GLSL uniforms that are set by these methods depend on the actual transformation.</p>
<h4><a class="anchor" id="sec-spheredeform">
Spherical deformation</a></h4>
<p>The <a class="el" href="classproland_1_1SphericalDeformation.html" title="A Deformation of space transforming planes to spheres.">proland::SphericalDeformation</a> deforms horizontal planes into spheres. It is intended to render planets of radius R (at sea level), using 6 terrains placed on the faces of a cube of size 2R x 2R x 2R, each terrain being deformed into a portion of the sphere:</p>
 
<center>
<img src="sdeformation.png" width="54%"> <img src="sideformation.png"
width="45%"><br/>
<div class="caption"><i>Left</i>: The spherical deformation can form
a planet with 6 deformed terrains. <i>Right</i>: the inverse
deformation maps the sphere to a developed cube.</div>
</center>
 <!--  <div align="center">
<img src="sdeformation.png" alt="sdeformation.png"/>
</div>
 <div align="center">
<img src="sideformation.png" alt="sideformation.png"/>
</div>
  --> <p>Mathematically, the deformation is defined as follows: from a point p=(x,y,z) in local space, we first construct the point P=(x,y,R) on the "top" (i.e., "north") cube face (in green in the above figure), in the <em>planet frame</em> (a reference frame whose origin is the planet center). This point is then used to define the deformed point, in the planet frame, as q=(R+z) P / &#x2225; P &#x2225;:</p>
<center> q = (R+z) P /  &#x2225; P &#x2225;, where P = (x,y,R) </center><p>This deformation maps the plane z=0 into a half-sphere. Hence at least two terrains are needed to cover the whole sphere. In order to limit deformations, it is better to use 6 terrains on the face of a cube, as shown above. The inverse deformation maps the whole sphere, except the south pole "face", to a developed cube in a plane (like for a cube map - see above figure). For the "north" face, the inverse deformation is:</p>
<center> p = (R q<sub>x</sub>/q<sub>z</sub>, R q<sub>y</sub>/q<sub>z</sub>,  &#x2225; q &#x2225; - R) </center><p>The tangent frame at some deformed point q, in which terrain normals are computed, is defined by the following unit vectors in planet frame:</p>
<center> <table border="0" cellspacing="3" cellpadding="0">
<tr>
<td><p>u<sub>x</sub> = (0,1,0)  &#215; u<sub>z</sub> /  &#x2225; (0,1,0)  &#215; u<sub>z</sub> &#x2225; </td></tr>
<tr>
<td><p>u<sub>y</sub> = u<sub>z</sub>  &#215; u<sub>x</sub> </p>
</td></tr>
<tr>
<td><p>u<sub>z</sub> = q /  &#x2225; q &#x2225; </td></tr>
</table>
</center><p><b>GLSL uniforms</b></p>
<p>In theory the transformation q = (R+z) P /  &#x2225; P &#x2225; can be easily implemented on GPU. There are however two precision problems, even with 32 bits floats. They are linked to the fact that transformed points are computed in a reference frame whose origin is at the planet center. Hence for a planet like the Earth, the coordinates of transformed points are large (of the order of R=6360000m) and do not have enough bits left to represent the altitude precisely. The other problem is when these coordinates are transformed into the reference frame of the camera, whose origin must also be expressed in the planet frame (subtracting two large numbers close to each other leads imprecise results).</p>
<p>In order to solve these two problems, the idea is to compute the deformed quad corners and to transform them in the camera frame on CPU, using double precision. The result are points with "small" coordinates, that can easily be interpolated on GPU without precision problems. More precisely we compute on CPU the deformed quad corners c<sub>i</sub> (i=1,...4) and the vertical vectors n<sub>i</sub> at these corners, in the camera frame, and we use them on GPU. The idea is to compute a deformed vertex as an interpolation of the deformed corners, displaced along an interpolation of the vertical vectors:</p>
 
<center>
<embed src="sdeformation.svg" width="80%" type="image/svg+xml"/><br/>
<div class="caption">A deformed point can be computed as the
interpolation of the deformed quad corners c, translated along the
interpolated corner verticals n.</div>
</center>
 <!--  <div align="center">
<img src="sdeformation.svg" alt="sdeformation.svg"/>
</div>
  --> <p>We note p<sub>i</sub> the corners of a quad in the local space, and c<sub>i</sub> the corresponding deformed points (c<sub>i</sub> = R P<sub>i</sub> /  &#x2225; P<sub>i</sub>  &#x2225;, where P<sub>i</sub> = (p<sub>ix</sub>,p<sub>iy</sub>,R) in the planet frame). We also note n<sub>i</sub> the deformed vertical vectors (n<sub>i</sub> = P<sub> i</sub> /  &#x2225; P<sub>i</sub>  &#x2225; in the planet frame). We want to compute the deformed point corresponding to a local point p defined as p= &#x2211;  &#945;<sub>i</sub> p<sub>i</sub> + (0,0,h) (with  &#x2211;  &#945;<sub>i</sub> = 1). And we want to express this deformed point q as</p>
<center> q =  &#x2211;  &#945;'<sub>i</sub> c<sub>i</sub> + h'  &#x2211;  &#945;'<sub> i</sub> n<sub>i</sub> </center><p>Finally we want that  &#x2211;  &#945;'<sub>i</sub> = 1 so that the above formula holds in any reference frame. The unknowns  &#945;'<sub> i</sub> and h' can be computed by writing the above relation in the planet frame, and by comparing it with the definition of q in this frame, q = (R+h) P /  &#x2225; P  &#x2225;:</p>
<center> <table border="0" cellspacing="3" cellpadding="0">
<tr>
<td><p>q =  &#x2211;  &#945;'<sub>i</sub> c<sub>i</sub> + h'  &#x2211;  &#945;'<sub>i</sub> n<sub>i</sub> = (R + h')  &#x2211;  &#945;'<sub> i</sub> P<sub>i</sub> /  &#x2225; P<sub>i</sub>  &#x2225; </td></tr>
<tr>
<td><p>q = (R + h) P /  &#x2225; P  &#x2225; = (R + h)  &#x2211;  &#945;<sub> i</sub> P<sub>i</sub> /  &#x2225;  &#x2211;  &#945;<sub>i</sub> P<sub>i</sub>  &#x2225; </td></tr>
<tr>
<td> &#x2211;  &#945;'<sub>i</sub> = 1 </p>
</td></tr>
</table>
</center><p>We can see that with  &#945;'<sub>i</sub> = k  &#945;<sub>i</sub>  &#x2225; P<sub>i</sub>  &#x2225; /  &#x2225;  &#x2211;  &#945;<sub>i</sub> P<sub>i</sub>  &#x2225; the first two lines become k.(R + h') = (R + h). We can then compute h' from k, and use the third equation to compute k. We get:</p>
<center> <table border="0" cellspacing="3" cellpadding="0">
<tr>
<td> &#945;'<sub>i</sub> =  &#945;<sub>i</sub>  &#x2225; P<sub>i</sub>  &#x2225; /  &#x2211;  &#945;<sub>i</sub>  &#x2225; P<sub>i</sub>  &#x2225; </td></tr>
<tr>
<td><p>h' = [h + R(1-k)] / k, where k =  &#x2225;  &#x2211;  &#945;<sub>i</sub> P<sub>i</sub>  &#x2225; /  &#x2211;  &#945;<sub>i</sub>  &#x2225; P<sub>i</sub>  &#x2225; </td></tr>
</table>
</center><p>We compute on CPU with double precision the deformed corners and verticals c<sub>i</sub> and n<sub>i</sub>, expressed directly in <em>screen space</em> (i.e., after transformation in the camera frame, and after the perspective projection). We also compute on CPU the norms  &#x2225; P<sub>i</sub>  &#x2225;. The <a class="el" href="classproland_1_1Deformation.html#ac80fb697439f19614899fe84e0ff5bae" title="Sets the shader uniforms that are necessary to project on screen the TerrainQuad...">proland::Deformation::setUniforms</a> method passes these values in the <code>screenQuadCorners</code> and <code>screenQuadVerticals</code> mat4 uniforms, and in the <code>screenQuadCornerNorms</code> vec4 uniform. The shader can then compute the screen space coordinates of the deformed vertices of the quad mesh with the following code (see the "terrain2" example for a concrete usage of this code - we assume that the "zfc" variable contains the elevation values zf,zc,zm for the current vertex):</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">float</span> R = deformation.radius;
mat4 C = deformation.screenQuadCorners;
mat4 N = deformation.screenQuadVerticals;
vec4 L = deformation.screenQuadCornerNorms;
vec3 P = vec3(vertex.xy * deformation.offset.z + deformation.offset.xy, R);

vec4 uvUV = vec4(vertex.xy, vec2(1.0) - vertex.xy);
vec4 alpha = uvUV.zxzx * uvUV.wwyy;
vec4 alphaPrime = alpha * L / dot(alpha, L);

<span class="keywordtype">float</span> h = zfc.z * (1.0 - blend) + zfc.y * blend;
<span class="keywordtype">float</span> k = min(length(P) / dot(alpha, L) * 1.0000003, 1.0);
<span class="keywordtype">float</span> hPrime = (h + R * (1.0 - k)) / k;

gl_Position = (C + hPrime * N) * alphaPrime;
</pre></div><p>This code first computes P= &#x2211;  &#945;<sub>i</sub> P<sub>i</sub> in <code>P</code>. It the computes the  &#945;<sub>i</sub> in <code>alpha</code>, based on the xy vertex coordinates (supposed to vary between 0 and 1 in the quad). It then computes the  &#945;'<sub>i</sub> in <code>alphaPrime</code>, computes h and k, computes h' from them in <code>hPrime</code>, and finally computes the result by interpolation using the <code>alphaPrime</code> coefficients.</p>
<p>The <a class="el" href="classproland_1_1Deformation.html#ac80fb697439f19614899fe84e0ff5bae" title="Sets the shader uniforms that are necessary to project on screen the TerrainQuad...">proland::Deformation::setUniforms</a> method also sets a <code>tangentFrameToWorld</code> mat3 uniform (using the u<sub>x</sub>, u<sub>y</sub> and u<sub>z</sub> defined above) that can be used to transform terrain normals expressed in the tangent frame at the center of the quad, into the planet frame:</p>
<div class="fragment"><pre class="fragment">vec3 Ntangent = ...; <span class="comment">// fetches normal in tangent space</span>
vec3 Nworld = deformation.tangentFrameToWorld * Ntangent;
</pre></div><h3><a class="anchor" id="sec-quad">
Terrain quadtree</a></h3>
<h4><a class="anchor" id="sec-quadsplit">
Distance-based subdivision</a></h4>
<p>The terrain framework represents a terrain with a quadtree that is dynamically subdivided based on the current viewer position, in order to provide more details near the viewer. <em>This subdivision is only based on the distance from the viewer to quads</em>, i.e., it does not depend on the "complexity" of the data tiles for these quads. More precisely, a quad is subdivided if its distance d to the viewer is less than k times its size L, where d is not an Euclidian distance, but a max(dx,dy) distance:</p>
 
<center>
<embed src="quadtree.svg" width="70%" type="image/svg+xml"/><br/>
<div class="caption">A quad is subdivided when its distance d to the
viewer (as defined above) is less than k times its size L. k is the
<i>split distance factor</i>.</div>
</center>
 <!--  <div align="center">
<img src="quadtree.svg" alt="quadtree.svg"/>
</div>
  --> <p>We call k the <em>split distance factor</em>. If you want to get a <em>restricted quadtree</em>, i.e., a quadtree in which the difference between the level of two neighbor quads is always 0 or 1, then k must be larger than 1:</p>
 
<center>
<embed src="quadtree2.svg" width="90%" type="image/svg+xml"/><br/>
<div class="caption">The split distance factor k must be larger than
1. <i>Left</i>: for a viewer in the gray area, the blue quad is
subdivided but not the red one, hence the quadtree is not restricted.
<i>Right</i>: with k>1 this problem disappears.</div>
</center>
 <!--  <div align="center">
<img src="quadtree2.svg" alt="quadtree2.svg"/>
</div>
  --> <p>Increasing the value of k means that quads are subdivided sooner, and appear smaller on screen. Hence you can tune the value of k to get a given resolution on screen. For instance, if each quad is rendered with a texture of TxT pixels, the projected size of these texture pixels on screen will be at most W/(2k.T.tan(fov/2)), where W is the screen width in pixels and fov is the field of view angle. The figure below gives an example of the result of this quadtree subdivision rule for several values of k above 1 (see also the "helloworld" example):</p>
 
<center>
<img src="quadtree.png" width="100%"><br/>
<div class="caption"><i>From left to right</i>: distance based
quadtree subdivision with k=1.1, 1.5, 2.0 and 2.8, with a viewer at
the red cross.</div>
</center>
 <!--  <div align="center">
<img src="quadtree.png" alt="quadtree.png"/>
</div>
  --> <dl class="note"><dt><b>Note:</b></dt><dd>in practice the distance between a quad and the viewer also involves altitudes: d=max(min(|x-ox|,|x-ox-L|), min(|y-oy|,|y-oy-L|), z-groundz), where z-groundz is the height of the camera above the ground. Note also that this distance is computed in the <em>local</em> space, not in the <em>deformed space</em> (see <a class="el" href="index.html#sec-deform">above</a>). For this the camera position is transformed from the deformed space to the local space.</dd></dl>
<h4><a class="anchor" id="sec-quadblend">
Continuous level of details</a></h4>
<p>When a quad is subdivided, popping can occur because the quad is suddenly replaced with 4 sub quads with new associated data. Hopefully, with k &gt; 1, it is possible to do a progressive fading in of the new sub tile data, and a corresponding fading out of the old parent tile data. This replaces a sudden transition with a progressive blending, much less visible. This blending can be done as follows: at some point x,y in a quad (ox,oy,l), if the viewer is at (cx,cy), then the blending coefficient defined as:</p>
<center> blend = clamp((d/l-k-1)/(k-1), 0, 1), where d=max(|x-cx|, |y-cy|) </center><p>can be used to mix the old parent tile data x<sub>parent</sub> and the new sub tile data x<sub>child</sub> with:</p>
<center> x = blend * x<sub>parent</sub> + (1-blend) * x<sub>child</sub> </center><p>Indeed when the viewer is at the minimal distance to the quad, d<sub>min</sub>=kl, we get blend = clamp(-1/(k-1), 0, 1) = 0, and x = x<sub>child</sub>. Inversely, when the viewer is at the maximal distance to the quad, d<sub>max</sub>=(2k+1)l, we get blend = clamp(k/(k-1), 0, 1) = 1 and x = x<sub>parent</sub>. It is easy to compute the distances at which the clamping occurs, which gives the width of the transition region between blend = 0 and blend = 1. This width is equal to (k - 1)l, which shows that the larger is k, the larger is the transition region, and the less noticeable is the transition. This is illustrated below:</p>
 
<center>
<img src="blend1.png" width="40%"> <img src="blend2.png" width="40%">
<br/>
<div class="caption">Blending coefficient (green) on top the of
quadtree (checkerboard). With k=1.2 (<i>left</i>) the transition
regions are smaller than with k=2 (<i>right</i>).</div>
</center>
 <!--  <div align="center">
<img src="blend1.png" alt="blend1.png"/>
</div>
 <div align="center">
<img src="blend2.png" alt="blend2.png"/>
</div>
  --> <p><b>GLSL uniforms</b></p>
<p>The <a class="el" href="classproland_1_1Deformation.html#ac80fb697439f19614899fe84e0ff5bae" title="Sets the shader uniforms that are necessary to project on screen the TerrainQuad...">proland::Deformation::setUniforms</a> method sets two uniforms that can be used to compute the above blending coefficient on GPU. The <code>deformation.camera</code> vec4 uniform stores the camera position, relatively to the quad lower left corner ox,oy and divided by the quad size l. The <code>deformation.blending</code> vec2 uniform stores k+1 and k-1. Using these uniforms, the blend coefficient can be computed as follows (the vertex coordinates are supposed to vary between 0 and 1 in the quad):</p>
<div class="fragment"><pre class="fragment">vec4 c = deformation.camera; <span class="comment">// (cx-ox)/l, (cy-oy)/l, (cz-groundz)/l</span>
vec2 k = deformation.blending; <span class="comment">// k+1, k-1</span>
vec2 v = abs(c.xy - gl_Vertex.xy);
<span class="keywordtype">float</span> d = max(max(v.x, v.y), c.z);
<span class="keywordtype">float</span> blend = clamp((d - k.x) / k.y, 0.0, 1.0);
</pre></div><h4><a class="anchor" id="sec-quadclasses">
Terrain classes</a></h4>
<p>A terrain quadtree is represented with a tree of <a class="el" href="classproland_1_1TerrainQuad.html" title="A quad in a terrain quadtree.">proland::TerrainQuad</a> objects. Each object of this class provides the following fields: </p>
<ul>
<li>
<p class="startli"><code>parent</code> gives a pointer to the parent quad.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><code>level</code>, <code>tx</code> and <code>ty</code> give the logical coordinates of the quad.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><code>ox</code>, <code>ox</code> and <code>l</code> give the physical coordinates of the quad.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><code>zmin</code> and <code>zmax</code> give the minimum and maximum elevations on the quad.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><code>children</code> is an array of four pointers to the sub quads of this quad. It contains either four NULL pointers if the quad is a leaf, or four non NULL pointers to four sub quads (in the bottom left, bottom right, top left, top right order) if this quad is subdivided.</p>
<p class="endli"></p>
</li>
<li>
<code>visible</code> indicates if this quad is invisible, partially visible or fully visible from the viewer. This field is updated by the <a class="el" href="classproland_1_1TerrainQuad.html#a7b049b92e825db7b4d74a2519ac7c208" title="Subdivides or unsubdivides this quad based on the current viewer distance to this...">proland::TerrainQuad::update</a> method. </li>
</ul>
<p>The <a class="el" href="classproland_1_1TerrainNode.html" title="A view dependent, quadtree based terrain.">proland::TerrainNode</a> class represents a terrain. It contains a pointer to the root of the terrain quadtree in <a class="el" href="classproland_1_1TerrainNode.html#a9022cec60ab80ef3bb7712a4003f4d91" title="The root of the terrain quadtree.">proland::TerrainNode::root</a>. It also contains the following fields: </p>
<ul>
<li>
<p class="startli"><code>splitDist</code> is the split distance factor k used for distance based subdivision (see above).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><code>maxLevel</code> is the quadtree level at which the subdivision must be stopped.</p>
<p class="endli"></p>
</li>
<li>
<code>deform</code> is the terrain deformation used for this terrain (see <a class="el" href="index.html#sec-deform">above</a>). </li>
</ul>
<p>Internally, a <a class="el" href="classproland_1_1TerrainNode.html" title="A view dependent, quadtree based terrain.">proland::TerrainNode</a> stores the current viewer position and the current view frustum planes. These current values can be retrieved in the local and deformed spaces (see <a class="el" href="index.html#sec-deform">Terrain deformation</a>) with <a class="el" href="classproland_1_1TerrainNode.html#abc15dab0ce0b3b62a6af31696109c65b" title="Returns the current viewer position in the deformed terrain space (see deform).">proland::TerrainNode::getDeformedCamera</a>, <a class="el" href="classproland_1_1TerrainNode.html#a99bd9a83ceed2692906c3646ec15e280" title="Returns the current viewer frustum planes in the deformed terrain space (see deform)...">proland::TerrainNode::getDeformedFrustumPlanes</a>, and <a class="el" href="classproland_1_1TerrainNode.html#a0f14c5e37890e53c0f7e10d3aae85b05" title="Returns the current viewer position in the local terrain space (see deform).">proland::TerrainNode::getLocalCamera</a>. They are updated by the <a class="el" href="classproland_1_1TerrainNode.html#a25b7d039d458975b2b31185c2547cebd" title="Updates the terrain quadtree based on the current viewer position.">proland::TerrainNode::update</a> method, which takes as argument a scene node defining the terrain position in world space (and from which the camera position can also be retrieved).</p>
<h4><a class="anchor" id="sec-resterrain">
Terrain resource</a></h4>
<p>A <a class="el" href="classproland_1_1TerrainNode.html" title="A view dependent, quadtree based terrain.">proland::TerrainNode</a> can be loaded with the Ork resource framework, using the following format:</p>
<div class="fragment"><pre class="fragment">
&lt;terrainNode name="myTerrain" size="6360000" zmin="0" zmax="10000"
    deform="sphere" splitFactor="2" maxLevel="16"/&gt;
</pre></div><p>This resource describes a terrain whose root quad has a size of 12720km x 12720km (12720 = 2*6360), whose elevations are between 0 and 10000m, using a spherical deformation (of course the length unit can be interpreted as you want). The terrain quadtree will be subdivided with a split distance factor k=2 (for a field of view of 80 degrees, and a viewport width of 1024 pixels. For a smaller field of view and/or a larger viewport, subdivisions will automatically occur at a larger distance, so that the size of a quad in pixels stays more or less the same), up to quadtree level 16 (included). Note: currently the optional <code>deform</code> attribute only supports the <code>none</code> and <code>sphere</code> values. In the case of a spherical deformation, the planet radius is set to <code>size</code>. The "terrain1" and "terrain2" examples illustrate how terrain nodes for flat and spherical terrains can be used.</p>
<h3><a class="anchor" id="sec-uniforms">
Texture tile samplers</a></h3>
<p>A <a class="el" href="classproland_1_1TerrainNode.html" title="A view dependent, quadtree based terrain.">proland::TerrainNode</a> only stores the current quadtree of a terrain, subdivided based on the distance to the current viewer position. It does <em>not</em> store any data associated with this quadtree. Indeed the terrain or more generally the landscape data is produced by tile producers, and stored in tile storages managed by tile caches (see <a class="el" href="index.html#sec-producerframework">Producer framework</a>). We therefore need a link between terrains and tile producers, so that producers are asked to produced new tiles when terrain quads are subdivided. This link is provided by the <a class="el" href="classproland_1_1TileSampler.html" title="A ork::Uniform to access texture tiles stored on GPU.">proland::TileSampler</a> class.</p>
<p>A <a class="el" href="classproland_1_1TileSampler.html" title="A ork::Uniform to access texture tiles stored on GPU.">proland::TileSampler</a> is associated with a single GPU tile producer. Its first role is to ask this producer to produce new tiles when a terrain quad is subdivided. Its second role is to set GLSL uniforms to allow a shader to access a texture tile in the tile storage used by this producer.</p>
<p>The first role is performed by the <a class="el" href="classproland_1_1TileSampler.html#a73f40642cbc7482afa3b25ff2523bd80" title="Returns the task graph necessary to create new texture tiles for newly created quads...">proland::TileSampler::update</a> method. This method takes as argument the root of a terrain quadtree. It compares this quadtree with its previous value during the last call to this method. Then, for each new quad, it asks the associated producer to produce the corresponding tile, with <a class="el" href="classproland_1_1TileProducer.html#adf72006cc497a5f13fe0dc3a7251879c">getTile</a>. Conversely, for each old quad (i.e., quads that are no longer part of the quadtree), it informs the producer that the corresponding tile is no longer used, by calling <a class="el" href="classproland_1_1TileProducer.html#ac9371d0fda7c4a8314378ca438871a5b">putTile</a>. This ensures that the tile data is "locked" (see <a class="el" href="index.html#sec-cache">Tile cache</a>) in the tile storage as long as the corresponding quad exists.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>in fact the <a class="el" href="classproland_1_1TileSampler.html#a73f40642cbc7482afa3b25ff2523bd80" title="Returns the task graph necessary to create new texture tiles for newly created quads...">proland::TileSampler::update</a> method returns a task graph containing all the tasks to produce the new tiles that must be produced. This task graph must be scheduled for execution in order to actually produce the tiles.</dd></dl>
<p>In practice it is not always necessary to produce a tile for each quad in the quadtree. For instance it is often sufficient to produce tiles for the <em>leaf</em> quads only, i.e., those that do not have sub quads, which are those that are effectively rendered. It is also common to produce tiles for the <em>visible</em> quads only, i.e., those that are fully or partially visible in the view frustum (see <a class="el" href="index.html#sec-quadclasses">Terrain classes</a>). In order to specify if a tile must be produced or not for a given quad, you can use the following configuration methods: </p>
<ul>
<li>
<p class="startli"><a class="el" href="classproland_1_1TileSampler.html#a1eaff1dc98fb9a7070b943e65534910a" title="Sets the option to create new tiles for leaf quads or not.">proland::TileSampler::setStoreLeaf</a> indicates whether a tile must be produced or not for leaf quads. The default is true.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="el" href="classproland_1_1TileSampler.html#a72a78bf6059d286b65b711e7ff11006f" title="Sets the option to create new tiles for non leaf quads or not.">proland::TileSampler::setStoreParent</a> indicates whether a tile must be produced or not for internal quads (i.e., non leaf quads). The default is true.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="el" href="classproland_1_1TileSampler.html#aeb14f7192ad238c0aee5ed08d7f15be9" title="Sets the option to create new tiles for invisible quads or not.">proland::TileSampler::setStoreInvisible</a> indicates whether a tile must be produced or not for quads out of the view frustum. The default is true.</p>
<p class="endli"></p>
</li>
<li>
<a class="el" href="classproland_1_1TileSampler.html#aa5364f9c0c3fbdacff253c8af212a189" title="Sets the options to create new tiles for arbitrary quads or not.">proland::TileSampler::setStoreFilter</a> adds an arbitrary <em>tile filter</em> to a list of filters. Each filter takes as argument a terrain quad, and returns whether or not a tile must be produced for it. If at least one filter decides that the tile must be produced, it will be produced. </li>
</ul>
<p>Finally a TileSampler can be used in one of two modes: synchronous or asynchronous. In the default, synchronous mode, the update method uses an immediate deadline for the tasks needed to produce the tiles for the newly created quads. This means that the final frame will not be displayed until all the tiles are produced. When tile data must be loaded from disk, with a high latency, this can lead to visible freeze time between frames when the viewer moves.</p>
<p>This can be solved by using the asynchronous mode. In this mode the deadline for the tile production tasks is not set to the current frame. Thus a frame can be displayed even if some data is missing. In this case the first ancestor tile that is ready is used instead. This solves the latency problem, but degrades the quality when the viewer is moving fast, and gives visible popping artifacts when new data suddenly replaces the temporary low resolution data used while waiting it (this can even lead to gaps between terrain quads because then the quadtree used for display is not necessarily a restricted quadtree). In order to use this asynchronous mode, several options must be configured properly (the "earth-srtm-async" example illustrates this - note in particular the scheduler definition): </p>
<ul>
<li>
<a class="el" href="classproland_1_1TileSampler.html#a72a78bf6059d286b65b711e7ff11006f" title="Sets the option to create new tiles for non leaf quads or not.">proland::TileSampler::setStoreParent</a> must be set to true. This is to ensure that we will find at least one ancestor whose data is ready when data for a tile is not yet ready. </li>
<li>
<a class="el" href="classproland_1_1TileSampler.html#ac23d400be2f3b0c6a7394e6c0ebed881" title="Sets the option to create new tiles for new quads in synchronous or asychronous way...">proland::TileSampler::setAsynchronous</a> must be set to true. </li>
<li>
finally the ork::Scheduler used must support prefetching of any kind of tasks (both CPU and GPU). With a ork::MultithreadScheduler, this is only possible if a prefetch rate is specified, or if a fixed frame rate is specified. </li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>You can mix TileSampler in synchronous mode with others using asynchronous mode. Hence some tile data can be produced synchronously while other data is produced asynchronously.</dd></dl>
<h4><a class="anchor" id="sec-samplertileglsl">
GLSL functions</a></h4>
<p>As said above, the second role of a <a class="el" href="classproland_1_1TileSampler.html" title="A ork::Uniform to access texture tiles stored on GPU.">proland::TileSampler</a> is to set GLSL uniforms allowing shaders to access a texture tile in the tile storage. This role is performed by the <a class="el" href="classproland_1_1TileSampler.html#ad16a33ae48b56997d37c851924736966" title="Sets the GLSL uniforms necessary to access the texture tile for the given quad.">proland::TileSampler::setTile</a> method, which takes as argument the logical coordinates of a tile. This method finds the location of this tile in the tile storage using <a class="el" href="classproland_1_1TileProducer.html#af6a7253ba9180d042cd07bbfe2ff622b">findTile</a>. It then sets the necessary GLSL uniforms to access the content of this storage slot from a shader. More precisely, if the requested tile is not found, its parent tile is looked for instead. If this parent tile is not found either, the parent of the parent tile is looked for, and so on until an ancestor of the requested tile is found. Then the necessary GLSL uniforms are set to allow shaders to access the sub part of the ancestor tile that corresponds to the requested tile.</p>
<p>In order to facilitate the use of texture tiles stored in tile storages, <em>a tile storage is seen as a new kind of texture</em>. By similarity with 1D, 2D, 2D array or 3D built-in textures, declared in GLSL with <code>sampler1D</code>, <code>sampler2D</code>, <code> sampler2DArray</code> or <code>sampler3D</code>, and used with the <code> texture1D()</code>, <code>texture2D()</code>, <code>texture2DArray()</code>, or <code>texture3D()</code> functions, we <em>define</em> a new <code>samplerTile</code> type and a new <code>textureTile</code> function for texture tiles stored in tile storages. Their definition is provided in the <code>textureTile.glsl</code> file.</p>
<p>Hence the tiles produced by a GPU tile producer <code>p</code> can be accessed as follows. We first create a <code>TileSampler</code> using this producer:</p>
<div class="fragment"><pre class="fragment">Ptr&lt;TileSampler&gt; u = <span class="keyword">new</span> TileSampler(<span class="stringliteral">&quot;mySamplerTile&quot;</span>, p);
</pre></div><p>The name "mySamplerTile" is the name of the <code>samplerTile</code> uniform that will be used in the shader to access the tiles. After the <code>update</code> method has been called, and after the tasks it returned have been executed, we can set the value of the "mySamplerTile" uniform to a specific tile, in the currently selected GLSL program (see ork::SceneManager::getCurrentProgram), with:</p>
<div class="fragment"><pre class="fragment">u-&gt;setTile(level, tx, ty);
</pre></div><p>Note the analogy with uniforms:</p>
<div class="fragment"><pre class="fragment">Ptr&lt;Uniform3f&gt; v = <span class="keyword">new</span> Uniform3f(<span class="stringliteral">&quot;myUniform&quot;</span>);
v-&gt;set(vec3f(1.0, 0.0, 0.0));
</pre></div><p>We can then render the corresponding quad. In the GLSL code, the tile can be accessed as follows (see the "terrain1" example):</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &quot;textureTile.glsl&quot;</span>

uniform samplerTile mySamplerTile;

<span class="keywordtype">void</span> main() {
    ...
    vec4 v = textureTile(mySamplerTile, uv);
    ...
}
</pre></div><p>where the uv coordinates must vary between 0 and 1 in the quad (note that <code>textureTile</code> does <em>not</em> sample the border of the tile, if any, but only the interior part: the [0..1] range is mapped to the interior part of the tile).</p>
<dl class="note"><dt><b>Note:</b></dt><dd>if the GPU storage uses textures in <code>NEAREST</code> mode, you can still perform a linear interpolation, in the shader, by using <code>textureTileLinear</code> instead of <code>textureTile</code> (this functions calls <code>textureTile</code> four times and interpolates the results).</dd></dl>
<h4><a class="anchor" id="sec-tilemap">
Tile maps</a></h4>
<p>With the above method a <code>samplerTile</code> uniform can access only one tile at a time in a shader. You can of course declare several <code>samplerTile</code> in your shader, in order to access several tiles (in the same storage or not) simultaneously. Still, you are limited to select a fixed number of tiles, draw the corresponding quad, select another set of tiles, draw the corresponding quad, and so on for all quads. However it is sometimes necessary to have access to all the tiles of a producer (or of several producers) simultaneously. This can be done with <em>tile maps</em>: a tile map is an indirection structure on GPU that indicates, for each tile, where it is stored in a tile storage. Since a storage can store the tiles of several producers, you can then have access to all the tiles of these producers.</p>
<p><b>Usage</b></p>
<p>A tile map is used via a <code>TileSampler</code>. But it is important to know that a <code>TileSampler</code> used to access a tile map does <em>not</em> ask its associated producer to produce new tiles when quads are subdivided. In other words it can only access tiles, it cannot produce them. Hence it is necessary to use a "companion" <code>TileSampler</code>, without tile map but associated with a tile producer using the <em>same</em> tile storage, so that tiles can be effectively produced (in fact you can have several such "companion" samplers).</p>
<p>A normal <code>TileSampler</code> can be changed to one used to access a tile map as follows: </p>
<ul>
<li>
<p class="startli">the first step is to declare the tile map in the GPU producer associated with the <code>TileSampler</code>, with the <code> tileMap="true"</code> attribute (see <a class="el" href="index.html#sec-gpustorage">GPUTileStorage</a>).</p>
<p class="endli"></p>
</li>
<li>
the terrain node with which the "companion" samplers are associated must be declared with <a class="el" href="classproland_1_1TileSampler.html#a973fd8fa821306805a9864e583e3eae1" title="Adds a terrain associated with this uniform.">proland::TileSampler::addTerrain</a>. </li>
</ul>
<p>The tile map can then be used by calling the <a class="el" href="classproland_1_1TileSampler.html#aac983e8bb8115810df1442d055538f73" title="Sets the GLSL uniforms necessary to access the texture tiles for arbitrary quads...">proland::TileSampler::setTileMap</a> method, before using the <code>textureQuadtree</code> function in your shader (the "terrainShader.glsl" file in the "terrain5" example illustrates this):</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &quot;textureTile.glsl&quot;</span>

uniform samplerTile myTiles;

<span class="keywordtype">void</span> main() {
    ...
    vec4 v = textureQuadtree(myTiles, xy, 0.0);
    ...
}
</pre></div><p>This function takes as argument x,y <em>physical coordinates</em> (varying between -L/2 and L/2, where L is the terrain size, i.e., the root quad size - see <a class="el" href="index.html#sec-producerframework">Producer framework</a>; the third argument, here 0.0, is the producer id). It first finds the logical coordinates of the leaf quad that contains this point, and then uses the tile map to find the storage slot containing the corresponding tile. It finally returns the content of this tile at the requested location.</p>
<p><b>Algorithm</b></p>
<p>The first step finds the logical coordinates (level,tx,ty) of the leaf quad q that contains the point p of physical coordinates (x,y), assuming that the quadtree of size L is subdivided using the split distance factor k&gt;1, with a viewer at (cx,cy). Once level is known, finding tx and ty is trivial (indeed tx =  &lfloor; 2<sup>level</sup> (x/L+1/2)  &rfloor;, and similarly for ty). So the main problem is to compute level.</p>
<p>Let's note d=max(|x-cx|,|y-cy|) the distance between p and the viewer, and d<sub>q</sub> the (unknown) distance between the <em>quad</em> q and the viewer. We have d<sub>q</sub> &lt; d &lt; d<sub>q</sub> + L/2<sup>level</sup>. By hypothesis q is not subdivided, which implies</p>
<center> kL/2<sup>level</sup> &lt; d<sub>q</sub> &lt; d </center><p>By hypothesis again the parent quad of q, noted r, is subdivided, which implies d<sub>r</sub> &lt; kL/2<sup>level-1</sup>. With d<sub> r</sub> &lt; d &lt; d<sub>r</sub> + L/2<sup>level-1</sup>, this gives</p>
<center> d &lt; (k+1)L/2<sup>level-1</sup> </center><p>We can then consider two cases: d &lt; kL/2<sup>level-1</sup>, or d &gt; kL/2<sup>level-1</sup>. In the first case we get with the first relation kL/2<sup>level</sup> &lt; d &lt; kL/2<sup>level-1</sup>, which gives level =  &lfloor; 1 + ln<sub>2</sub>(kL/d) &rfloor;. In the second case we get with the second relation kL/2<sup>level-1</sup> &lt; d &lt; (k+1)L/2<sup>level-1</sup>. After some rewriting, this gives 1 + ln<sub>2</sub>(kL/d) &lt; level &lt; 1 + ln<sub>2</sub>(kL/d) + ln<sub> 2</sub>(1+1/k) &lt; 2 + ln<sub>2</sub>(kL/d). We conclude that, in both cases,  &lfloor; 1 + ln<sub>2</sub>(kL/d) &rfloor;  &le; level  &le;  &lfloor; 2 + ln<sub>2</sub>(kL/d) &rfloor;. So we compute level as follows: we first compute l =  &lfloor; 1 + ln<sub>2</sub>(kL/d) &rfloor;, deduce tx and ty from that, and test if the distance d<sub>q</sub> for this quad is less than kL/2<sup>l</sup> or not. Depending on the result, we know that level is either l or l + 1.</p>
<p>Once we have the logical tile coordinates, the second step must find where this tile is stored in the tile storage. This is the role of the <em>tile map</em>, which stores for each tile its slot in the storage (if present in the storage). In fact this map cannot have one entry for <em>each</em> potential tile: for a quadtree depth of 16, there are more than 4<sup>16</sup> potential tiles, i.e., more than 4 billions entries! A solution is to store an encoding of the quadtree on GPU. But finding a tile would require a full tree traversal. Another solution is to use a hash table on GPU, but it would be difficult to avoid collisions to ensure a maximum efficiency. We use another solution, which ensures a constant time access (no tree traversal, no collisions, small memory requirements). We use the fact that, at each quadtree level, the number of leaf tiles that can exist simultaneously is bounded and independent of the level.</p>
<p>A tile (l,tx,ty) cannot exist if its parent tile is not subdivided. If the viewer is at (cx,cy), the parent tile containing the viewer, (l-1, &lfloor; 2<sup>l-1</sup>(cx/L+1/2)  &rfloor;,  &lfloor; 2<sup> l-1</sup>(cy/L+1/2)  &rfloor;) is subdivided. And all tiles of level l-1 at a distance less than kL/2<sup>l-1</sup> are also subdivided. This gives at most  &lceil; k &rceil; such tiles around the parent tile, i.e., at most (2 &lceil; k &rceil;+1)<sup>2</sup> tiles of level l-1. Hence there are at most (4 &lceil; k &rceil;+2)<sup>2</sup> leaf tiles of level l at the same time, whatever the value of l. For k&lt;2, this gives a tile map of size 10<sup>2</sup>.depth, e.g., 1600 entries for a maximum depth of 16 (instead of 4 billions!).</p>
<p>In summary the CPU updates the tile map texture (at each frame, depending on the current cx,cy value) by storing for each leaf quad (l,tx,ty) its slot in the storage, in the texel of index</p>
<center> i = ix + iy.(4  &lceil; k  &rceil; + 2) + l.(4  &lceil; k  &rceil; + 2)<sup> 2</sup> </center><p> where </p>
<center> ix = tx - 2 &lfloor; 2<sup>l-1</sup>(cx/L+1/2)  &rfloor; +  &lceil; k  &rceil; <br/>
 iy = ty - 2 &lfloor; 2<sup>l-1</sup>(cy/L+1/2)  &rfloor; +  &lceil; k  &rceil; </center><p>On GPU, once the (l,tx,ty) coordinates corresponding to the physical coordinates (x,y) have been found, the index i is computed, the value of the tile map at this index is retrieved to get the slot position, and finally the texture tile in this slot is sampled to get the result. The "terrainShader.glsl" file in the "terrain5" example contains a concrete implementation of the above algorithm.</p>
<h4><a class="anchor" id="sec-samplertileres">
Texture tile sampler resource</a></h4>
<p>A <a class="el" href="classproland_1_1TileSampler.html" title="A ork::Uniform to access texture tiles stored on GPU.">proland::TileSampler</a> can be loaded with the Ork resource framework, using the following format (see the "terrain1" example):</p>
<div class="fragment"><pre class="fragment">
&lt;tileSampler sampler="mySamplerTile" producer="myProducer"
    storeLeaf="true" storeParent="false" storeInvisible="false"/&gt;
</pre></div><p>The <code>sampler</code> attribute specifies the name of the GLSL <code>samplerTile</code> uniform that will be set by <code>setTile</code>. The <code>producer</code> attribute is the name of a GPU tile producer resource. The <code>storeLeaf</code>, <code>storeParent</code> and <code>storeInvisible</code> attributes are options that specify when a tile must be produced for a given quad (see above). Using <code>tileSamplerZ</code> instead of <code>tileSampler</code> creates a sub class of <code>TileSampler</code> that reads back the tile data on GPU, supposed to be elevation tiles, and uses this data to update the zmin and zmax fields of terrain quads (see <a class="el" href="index.html#sec-quadclasses">Terrain classes</a>), as well as the terrain height under the camera, in <a class="el" href="classproland_1_1TerrainNode.html#a8a3349347003f58994bcd3cac11927ae" title="The terrain elevation below the current viewer position.">proland::TerrainNode::groundHeightAtCamera</a>.</p>
<p>A <a class="el" href="classproland_1_1TileSampler.html" title="A ork::Uniform to access texture tiles stored on GPU.">proland::TileSampler</a> to access a tile map can be loaded as follows (see the "terrain5" example):</p>
<div class="fragment"><pre class="fragment">
&lt;tileSampler sampler="mySamplerTile" producer="myProducer"
    terrains="myTerrain1,myTerrain2,myTerrain3"/&gt;
</pre></div><p>where the <code>terrain</code> attribute specifies the "companion" <a class="el" href="classproland_1_1TileSampler.html" title="A ork::Uniform to access texture tiles stored on GPU.">proland::TileSampler</a>, indirectly via terrain node resources (you can specify at most 6 terrains).</p>
<h3><a class="anchor" id="sec-tasks">
Terrain tasks</a></h3>
<p>Three ork::AbstractTask sub classes are provided to update a terrain node, to update a texture tile sampler, and finally to draw a terrain.</p>
<h4><a class="anchor" id="sec-updateterrain">
UpdateTerrainTask</a></h4>
<p>The <a class="el" href="classproland_1_1UpdateTerrainTask.html" title="An AbstractTask to update a terrain quadtree.">proland::UpdateTerrainTask</a> simply calls the <a class="el" href="classproland_1_1TerrainNode.html#a25b7d039d458975b2b31185c2547cebd" title="Updates the terrain quadtree based on the current viewer position.">proland::TerrainNode::update</a> method on a terrain. This updates the terrain quadtree, based on the new current camera position. A <a class="el" href="classproland_1_1UpdateTerrainTask.html" title="An AbstractTask to update a terrain quadtree.">proland::UpdateTerrainTask</a> can be created with the Ork resource framework, using the following format (the "helloworld" example illustrates this):</p>
<div class="fragment"><pre class="fragment">
&lt;updateTerrain name="this.terrain"/&gt;
</pre></div><p>the <code>name</code> attribute specifies the terrain node that must be updated. It can have the following form: </p>
<ul>
<li>
<p class="startli"><em>name</em>: in this case the terrain node is the terrain node resource whose name is <em>name</em>.</p>
<p class="endli"></p>
</li>
<li>
<code>this.</code><em>name</em>, <code>$</code>v<code>.</code><em>name</em>, <em>flag</em><code>.</code><em>name</em>: in this case the terrain node is the value of the field <em>name</em> (see Scene nodes) of the target <em>scene node</em> <code>this</code>, <code>$</code>v or <em>flag</em> (see Methods). </li>
</ul>
<h4><a class="anchor" id="sec-updateuniforms">
UpdateTileSamplersTask</a></h4>
<p>The <a class="el" href="classproland_1_1UpdateTileSamplersTask.html" title="An AbstractTask to update the TileSampler associated with a terrain.">proland::UpdateTileSamplersTask</a> simply calls the proland::UniformSamplerTask::update method on a set of texture tile samplers. This produces tiles for the new quads that appeared since the last execution of this task. A <a class="el" href="classproland_1_1UpdateTileSamplersTask.html" title="An AbstractTask to update the TileSampler associated with a terrain.">proland::UpdateTileSamplersTask</a> can be created with the Ork resource framework, using the following format (the "terrain1" example illustrates this):</p>
<div class="fragment"><pre class="fragment">
&lt;updateUniform name="this.terrain"/&gt;
</pre></div><p>the <code>name</code> attribute specifies a terrain node. It can have the following form: </p>
<ul>
<li>
<p class="startli"><em>name</em>: in this case the terrain node is the terrain node resource whose name is <em>name</em>.</p>
<p class="endli"></p>
</li>
<li>
<code>this.</code><em>name</em>, <code>$</code>v<code>.</code><em>name</em>, <em>flag</em><code>.</code><em>name</em>: in this case the terrain node is the value of the field <em>name</em> (see Scene nodes) of the target <em>scene node</em> <code>this</code>, <code>$</code>v or <em>flag</em> (see Methods). </li>
</ul>
<p>This task updates all the texture tile samplers that are associated with the scene node to which the Ork method that executes this task belongs. Indeed a scene node can have associated uniforms, including <a class="el" href="classproland_1_1TileSampler.html" title="A ork::Uniform to access texture tiles stored on GPU.">proland::TileSampler</a> (a sub class of ork::Uniform).</p>
<h4><a class="anchor" id="sec-drawterrain">
DrawTerrainTask</a></h4>
<p>The <a class="el" href="classproland_1_1DrawTerrainTask.html" title="An AbstractTask to draw a terrain.">proland::DrawTerrainTask</a> draws a mesh for each leaf quad of a terrain, using the currently selected program. Typically the mesh is a regular grid mesh, which is translated, scaled, and displaced by the GLSL program to draw each quad at the proper location in the terrain. Before drawing each quad, this task sets the uniforms that are necessary to deform the terrain quad with <a class="el" href="classproland_1_1Deformation.html#ac80fb697439f19614899fe84e0ff5bae" title="Sets the shader uniforms that are necessary to project on screen the TerrainQuad...">proland::Deformation::setUniforms</a>. It also sets the uniforms necessary to access the tiles for this quad, using <a class="el" href="classproland_1_1TileSampler.html#ad16a33ae48b56997d37c851924736966" title="Sets the GLSL uniforms necessary to access the texture tile for the given quad.">proland::TileSampler::setTile</a> or <a class="el" href="classproland_1_1TileSampler.html#aac983e8bb8115810df1442d055538f73" title="Sets the GLSL uniforms necessary to access the texture tiles for arbitrary quads...">proland::TileSampler::setTileMap</a> (for each texture tile sampler associated with the scene node to which the Ork method that executes this task belongs).</p>
<p>A <a class="el" href="classproland_1_1DrawTerrainTask.html" title="An AbstractTask to draw a terrain.">proland::DrawTerrainTask</a> can be created with the Ork resource framework, using the following format:</p>
<div class="fragment"><pre class="fragment">
&lt;drawTerrain name="this.terrain" mesh="this.grid" culling="true"/&gt;
</pre></div><p>the <code>name</code> attribute specifies a terrain node. It can have the following form: </p>
<ul>
<li>
<p class="startli"><em>name</em>: in this case the terrain node is the terrain node resource whose name is <em>name</em>.</p>
<p class="endli"></p>
</li>
<li>
<code>this.</code><em>name</em>, <code>$</code>v<code>.</code><em>name</em>, <em>flag</em><code>.</code><em>name</em>: in this case the terrain node is the value of the field <em>name</em> (see Scene nodes) of the target <em>scene node</em> <code>this</code>, <code>$</code>v or <em> flag</em> (see Methods). </li>
</ul>
<p>The <code>mesh</code> attribute is the name of a mesh resource (see Meshes). It specifies the mesh that is used to draw each leaf quad. It can have the following form: </p>
<ul>
<li>
<p class="startli"><em>name</em>.mesh: in this case the mesh is the mesh resource whose name is <em>name</em>.mesh.</p>
<p class="endli"></p>
</li>
<li>
<code>this.</code><em>name</em>, <code>$</code>v<code>.</code><em>name</em>, <em>flag</em><code>.</code><em>name</em>: in this case the mesh is the mesh <em>name</em> of the target scene node <code>this</code>, <code>$</code>v or <em>flag</em> (see Methods). </li>
</ul>
<p>The <code>culling</code> attribute specifies if all the leaf quads must be drawn, or only those that are in the view frustum. The default value is false, meaning that all leaf quads are drawn.</p>
<h2><a class="anchor" id="sec-ui">
User Interface</a></h2>
<p>Proland's whole interface is based on <a class="el" href="">EventHandlers</a>. To be user-friendly and quickly usable, it provides the basics for navigating through the large scenes that you can display in Proland.</p>
<p>The UI is split in two parts: The handling of events (for navigation, edition, ...), and the <a href="http://www.antisphere.com/Wiki/tools:anttweakbar">TweakBars</a>, used to provide a visual help for these options. TweakBars are also EventHandlers, which enables them to use the keyboard, mouse and OpenGL events.</p>
<h3><a class="anchor" id="sec-defaulthandlers">
Default Handlers</a></h3>
<h4><a class="anchor" id="sec-basicviewhandler">
View Handlers</a></h4>
<p>When using a library such as Proland, a user-friendly navigation system is mandatory. Proland provides such a system, called <a class="el" href="classproland_1_1BasicViewHandler.html" title="An EventHandler to control a TerrainViewController and a light source with the mouse...">proland::BasicViewHandler</a>. Its behavior is quite straight-forward: When no other EventHandler catches the keyboard/mouse events, it uses them for navigation. The default navigation system is the following: PageUp and PageDown to move forward and backward (Z axis). The mouse left-click moves the camera along X and Y axis, while the right-click makes the sun turn around the SceneNode. CTRL + click turns the camera. The mouse wheel is the same as PageUp and PageDown.</p>
<p><a class="el" href="classproland_1_1BasicViewHandler.html" title="An EventHandler to control a TerrainViewController and a light source with the mouse...">proland::BasicViewHandler</a> requires a proland::BasicViewHandler::ViewManager in order to work properly. This ViewManager provides acces to a ork::SceneManager, to a <a class="el" href="classproland_1_1TerrainViewController.html" title="A view controller for flat terrains.">proland::TerrainViewController</a> and to the screen to world transformation. BasicViewHandler directly computes the new position at each frame, and sets it in the TerrainViewController's camera position.</p>
<p><a class="el" href="classproland_1_1TerrainViewController.html" title="A view controller for flat terrains.">proland::TerrainViewController</a> controls the camera position and orientation. The default implementation uses a flat terrain as root node, but Proland provides implementations for <a class="el" href="classproland_1_1PlanetViewController.html">planets</a> and <a class="el" href="classproland_1_1CylinderViewController.html">cylinders</a> as well.</p>
<p>BasicViewHandler can be loaded in the Ork Resource framework: </p>
<div class="fragment"><pre class="fragment">
&lt;basicViewHandler name="myViewHandler" viewManager="myWindow" 
    next="anOptionnalEventHandler"/&gt;
</pre></div><ul>
<li><code>viewManager</code>: the proland::BasicViewHandler::ViewManager object that handles the Navigation UI.</li>
<li><code>next</code>: an optional EventHandler that will receive the Events not captured by the view handler.</li>
</ul>
<p>The "terrain3" example illustrates how this view handler can be used (especially when compared with the "terrain2" example) without Ork resources. The "ocean1" example illustrates how it can be used via Ork resources.</p>
<h4><a class="anchor" id="sec-eventrecorder">
Event Recorder</a></h4>
<p>The user might want to record a set of actions and to replay it later, or to create some videos of what he's doing in Proland. The <a class="el" href="classproland_1_1EventRecorder.html" title="An EventHandler that can record and replay events, and save a video during replay...">proland::EventRecorder</a> is able to do that. When pressing F12, it starts recording every <a class="el" href="structproland_1_1EventRecorder_1_1Event.html">events</a> occuring until F12 is pressed again (all keyboard, mouse and OpenGL events are recorded together with the time at which they occured). Then, the user can replay them by pressing F11. When pressing Shift + F11, frames will be saved on the disk at a rate of 25 frames per second (using the original dates of each event, not the time during replay, which is perturbed by the time it takes to save frames on disk). This allows users to create a video afterwards. It is also able to save and load the recorded Events.</p>
<p>EventRecorder records the Events provided by a <a class="el" href="">Recordable</a> object. It works as a transparent layer on EventHandlers, i.e. it takes the place of an UI manager (a view handler for example), records all the events, and then passes them to the real UI manager, except when playing a video.</p>
<p>EventRecorder can be loaded in the Ork Resource framework: </p>
<div class="fragment"><pre class="fragment">
&lt;eventRecorder name="myEventRecorder" recorded="myWindow" 
    videoDirectory="\home\myVideos\" cursorTexture"cursor" next="myBasicViewHandler"/&gt;
</pre></div><ul>
<li><code>recorded</code> the Recordable resource recorded by this EventRecorder.</li>
<li><code>videoDirectory</code> the file name format to be used to save the video frames.</li>
<li><code>cursorTexture</code> a cursor texture to display the cursor position during replay.</li>
<li><code>next</code> the EventHandler that must handle the events recorded and replayed by this EventRecorder.</li>
</ul>
<h3><a class="anchor" id="sec-twbars">
TweakBars</a></h3>
<p>Apart from the controls, the Graphical part of the UI is also important, and the user must be able to quickly use the interface without knowing all the hotkeys used in the program. Plus, the information must be clearly visible, and easily managed for the developper. Philippe Decaudin developped a toolbar framework that has those qualities: AntTweakBars. Proland's toolbar are based on this framework.</p>
<p>To avoid displaying too many toolbars on the screen, Proland contains a <a class="el" href="classproland_1_1TweakBarManager.html" title="Provides a modular tweak bar made of several TweakBarHandler.">proland::TweakBarManager</a>, able to add the content from any poland::TweakBarHandler, and enable/disable them. When deactivated, they can themselves disable their linked EventHandler, if any (an editor for example). The TweakBarHandlers can be of three types: permanent (will always be activated), exclusive (they can't be enabled in the same time as other exclusive handlers) or regular (can be enabled/disabled at will).</p>
<p>As for EventRecorder, TweakBarManager is a transparent layer on a given UI manager. It is an EventHandler, thus able to catch events and to pass them to its TweakBarHandlers. Those will then determine if anything should be changed in the data they display; If it did, the manager will recreate the tweakbar with updated content.</p>
<p>Once again, the TweakBarManager can be loaded with the Ork Resource framework: </p>
<div class="fragment"><pre class="fragment">
&lt;tweakBarManager name="myTweakBarManager" minimized="false" next="myViewManager"&gt;
    &lt;editor id="myEditor1" bar="myTweakBarEditor"
        exclusive="true" permanent="false" key="r"/&gt;
&lt;\tweakBarManager&gt;
</pre></div><ul>
<li><code>minimized</code>: Determines if the TweakBarManager starts minimized or not.</li>
<li><code>next</code>: the EventHandler that must handle the unused events.</li>
<li><code>bar</code>: a TweakBarHandler that will add its content to the TweakBarManager.</li>
<li><code>exclusive</code>: Determines if the TweakBarHandler will be exclusive or not. Only one exclusive handler can be activated at the same time.</li>
<li><code>permanent</code>: Determines if the TweakBarHandler can be disabled.</li>
<li><code>key</code>: an optionnal hotkey to disable/enable the TweakBarHandler.</li>
</ul>
<p>A few Tweakbars are available by default:</p>
<ul>
<li><a class="el" href="classproland_1_1TweakResource.html" title="A TweakBarHandler to edit resources.">proland::TweakResource</a>: a flexible TweakBar directly described in the XML file, just like any other ork resource.</li>
<li><a class="el" href="classproland_1_1TweakSceneGraph.html" title="A TweakBarHandler to control the scene graph.">proland::TweakSceneGraph</a>: Enables to control the scene graph. Uses a <a class="el" href="classproland_1_1SceneVisitor.html" title="A visitor to visit a scene graph.">proland::SceneVisitor</a> object to browse the scene graph and display every nodes in the scene. Then, it allows the user to enable/disable almost any node.</li>
<li><a class="el" href="classproland_1_1TweakViewHandler.html" title="A TweakBarHandler to control a BasicViewHandler.">proland::TweakViewHandler</a>: Controls a BasicViewHandler. Contains predefined positions accessible in one click. Also displays the current position.</li>
</ul>
<p>The Proland examples illustrate how these tweak bars can be used (in particular the "edit1", "edit2", "edit3" and "edit4" examples). The figure below shows the interface of the <a class="el" href="classproland_1_1TweakSceneGraph.html" title="A TweakBarHandler to control the scene graph.">proland::TweakSceneGraph</a>: the tweak bar gives a tree representation of the scene graph, where each scene node can be expanded (allowing to show / hide this node, view its producers, invalidate their tiles, etc). This bar also gives a list of textures whose content can be displayed (on the right we see the texture used for the ortho producer tile cache). Finally it also shows statistics about the tile caches (capacity, number of tiles in use or not, etc).</p>
 
<center>
<img src="ui.png" width="80%">
<div class="caption">The interface of the proland::TweakSceneGraph tweak bar.
You can move and resize the right window with the mouse, and move its content
with SHIFT+mouse drag. You can zoom in with CTRL mouse drag, and zoom in
and out with the mouse wheel. A right click resets the view.</div>
</center>
 <!--  <div align="center">
<img src="ui.png" alt="ui.png"/>
</div>
  -->  </div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Sat May 12 09:41:36 2012 for proland by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
