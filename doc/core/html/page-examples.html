<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>proland: Examples</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="page-examples">Examples </a></h1> 
<div class="mainpage">
<h2><a class="anchor" id="sec-helloworld">
HelloWorld example</a></h2>
 
<img src="helloworld.png"><br/>
 <!--  <div align="center">
<img src="helloworld.png" alt="helloworld.png"/>
</div>
  --> <p>This example is a minimal example using only the proland terrain framework (see <a class="el" href="index.html#sec-terrain">Terrain framework</a>), without any producer. It simply uses a dynamic quadtree, and draws each terrain quad with an OpenGL quad and a simple shader.</p>
<h3><a class="anchor" id="sec-helloworld-main">
Main class</a></h3>
<p>The main class is defined as follows:</p>
<p><div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;stdlib.h&gt;</span>

<span class="preprocessor">#include &quot;ork/core/FileLogger.h&quot;</span>
<span class="preprocessor">#include &quot;ork/render/FrameBuffer.h&quot;</span>
<span class="preprocessor">#include &quot;ork/resource/XMLResourceLoader.h&quot;</span>
<span class="preprocessor">#include &quot;ork/scenegraph/SceneManager.h&quot;</span>
<span class="preprocessor">#include &quot;ork/ui/GlutWindow.h&quot;</span>

<span class="preprocessor">#include &quot;proland/util/TerrainViewController.h&quot;</span>

<span class="keyword">using namespace </span>ork;
<span class="keyword">using namespace </span>proland;

<span class="keyword">class </span>HelloWorld : <span class="keyword">public</span> GlutWindow
{
<span class="keyword">public</span>:
    ptr&lt;SceneManager&gt; manager;
    ptr&lt;TerrainViewController&gt; controller;
    <span class="keywordtype">int</span> mouseX, mouseY;
    <span class="keywordtype">bool</span> rotate;
</pre></div></p>
<p>Here we simply include the headers we need, and declare a subclass of ork::GlutWindow. This class will define what must be drawn at each frame, and how mouse and keyboard events must be handled. For this it uses a ork::SceneManager, i.e., the scene to be rendered, as well as a <a class="el" href="classproland_1_1TerrainViewController.html" title="A view controller for flat terrains.">proland::TerrainViewController</a> to hold the current camera position, and three additional fields to handle mouse events.</p>
<p><div class="fragment"><pre class="fragment">
    HelloWorld() : GlutWindow(Window::Parameters().size(1024, 768))
    {
        FileLogger::File *out = <span class="keyword">new</span> FileLogger::File(<span class="stringliteral">&quot;log.html&quot;</span>);
        Logger::INFO_LOGGER = <span class="keyword">new</span> FileLogger(<span class="stringliteral">&quot;INFO&quot;</span>, out, Logger::INFO_LOGGER);
        Logger::WARNING_LOGGER = <span class="keyword">new</span> FileLogger(<span class="stringliteral">&quot;WARNING&quot;</span>, out, Logger::WARNING_LOGGER);
        Logger::ERROR_LOGGER = <span class="keyword">new</span> FileLogger(<span class="stringliteral">&quot;ERROR&quot;</span>, out, Logger::ERROR_LOGGER);
</pre></div></p>
<p>The constructor first sets up some Ork loggers. By default the DEBUG logger is null, and the INFO, WARNING and ERROR logger simply log to the command line. Here we create file loggers around the default loggers, in order to also log events into the "log.html" file.</p>
<p><div class="fragment"><pre class="fragment">
        ptr&lt;XMLResourceLoader&gt; resLoader = <span class="keyword">new</span> XMLResourceLoader();
        resLoader-&gt;addPath(<span class="stringliteral">&quot;.&quot;</span>);
        resLoader-&gt;addArchive(<span class="stringliteral">&quot;helloworld.xml&quot;</span>);

        ptr&lt;ResourceManager&gt; resManager = <span class="keyword">new</span> ResourceManager(resLoader, 8);

        manager = <span class="keyword">new</span> SceneManager();
        manager-&gt;setResourceManager(resManager);
</pre></div></p>
<p>We then create a resource loader, and configure it to load resources from the current directory and from the "helloworld.xml" archive file. Then we create a resource manager using this loader, and a ork::SceneManager using this resource manager.</p>
<p><div class="fragment"><pre class="fragment">
        manager-&gt;setScheduler(resManager-&gt;loadResource(<span class="stringliteral">&quot;defaultScheduler&quot;</span>).cast&lt;Scheduler&gt;());
        manager-&gt;setRoot(resManager-&gt;loadResource(<span class="stringliteral">&quot;scene&quot;</span>).cast&lt;SceneNode&gt;());
        manager-&gt;setCameraNode(<span class="stringliteral">&quot;camera&quot;</span>);
        manager-&gt;setCameraMethod(<span class="stringliteral">&quot;draw&quot;</span>);
</pre></div></p>
<p>We finally configure the scene manager: we set its task scheduler by loading it with the resource loader, we set its scene graph by loading it with the resource loader, and we finally define which node and method to use for the camera.</p>
<p><div class="fragment"><pre class="fragment">
        controller = <span class="keyword">new</span> TerrainViewController(manager-&gt;getCameraNode(), 2500.0);
    }
</pre></div></p>
<p>As a last step in this constructor, we create an object that will hold the current camera position, and which will also set the corresponding transformation matrices in the camera node (given by <code>manager-&gt;getCameraNode()</code>). 2500.0 is the initial camera altitude.</p>
<p><div class="fragment"><pre class="fragment">
    <span class="keyword">virtual</span> ~HelloWorld()
    {
    }

    <span class="keyword">virtual</span> <span class="keywordtype">void</span> redisplay(<span class="keywordtype">double</span> t, <span class="keywordtype">double</span> dt)
    {
        controller-&gt;update();
        controller-&gt;setProjection();

        ptr&lt;FrameBuffer&gt; fb = FrameBuffer::getDefault();
        fb-&gt;clear(<span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);

        manager-&gt;update(t, dt);
        manager-&gt;draw();

        GlutWindow::redisplay(t, dt);

        <span class="keywordflow">if</span> (Logger::ERROR_LOGGER != NULL) {
            Logger::ERROR_LOGGER-&gt;flush();
        }
    }
</pre></div></p>
<p>The redisplay method defines how the scene must be rendered at each frame. Its implementation is very simple, as most of the work is done by the scene manager. The first two lines copy the camera position stored in the view controller into the scene node corresponding to the camera. The following lines clear the screen, update the scene graph, and draw it on screen. Finally the overriden redisplay method is called to actually display the new frame (this method internally calls glutSwapBuffer).</p>
<p><div class="fragment"><pre class="fragment">
    <span class="keyword">virtual</span> <span class="keywordtype">void</span> reshape(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y)
    {
        ptr&lt;FrameBuffer&gt; fb = FrameBuffer::getDefault();
        fb-&gt;setDepthTest(<span class="keyword">true</span>, LESS);
        fb-&gt;setViewport(vec4&lt;GLint&gt;(0, 0, x, y));
        GlutWindow::reshape(x, y);
    }
</pre></div></p>
<p>The reshape method is called when the window is resized. It simply updates the viewport of the screen framebuffer to match the new window size.</p>
<p><div class="fragment"><pre class="fragment">
    <span class="keyword">virtual</span> <span class="keywordtype">void</span> idle(<span class="keywordtype">bool</span> damaged)
    {
        GlutWindow::idle(damaged);
        <span class="keywordflow">if</span> (damaged) {
            manager-&gt;getResourceManager()-&gt;updateResources();
        }
    }
</pre></div></p>
<p>The idle method is called when no other event occured. Its damaged argument indicates whether a part of the window has been uncovered by another window since the last call to this method, or if the window just got the focus. If it is the case, we check if resources have changed on disk, and if so we update them (all this is done by the updateResources method).</p>
<p><div class="fragment"><pre class="fragment">
    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> mouseClick(button b, state s, modifier m, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y)
    {
        mouseX = x;
        mouseY = y;
        rotate = (m &amp; CTRL) != 0;
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
    }

    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> mouseMotion(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y)
    {
        <span class="keywordflow">if</span> (rotate) {
            controller-&gt;phi += (mouseX - x) / 500.0;
            controller-&gt;theta += (mouseY - y) / 500.0;
        } <span class="keywordflow">else</span> {
            vec3d oldp = manager-&gt;getWorldCoordinates(mouseX, mouseY);
            vec3d p = manager-&gt;getWorldCoordinates(x, y);
            <span class="keywordflow">if</span> (valid(oldp) &amp;&amp; valid(p)) {
                controller-&gt;move(oldp, p);
            }
        }
        mouseX = x;
        mouseY = y;
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
    }

    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> mouseWheel(wheel b, modifier m, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y)
    {
        <span class="keywordflow">if</span> (b == WHEEL_DOWN) {
            controller-&gt;d *= 1.1;
        }
        <span class="keywordflow">if</span> (b == WHEEL_UP) {
            controller-&gt;d /= 1.1;
        }
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
    }
</pre></div></p>
<p>The mouseClick, mouseMotion and mouseWheel methods implement a simple user interface to navigate in the terrain. A mouse drag translates the camera, while a mouse drag with CTRL rotates the camera around the point of the terrain which is at the center of the screen. Finally the mouse wheel moves the camera closer or farther away from this "center point". These methods are implemented by modifying the x0 and y0 fields in the view controller (which correspond to the terrain coordinates of the center point), its theta and phi fields (which correspond to the camera orientation around the center point), and its d field (which corresponds to the distance between the camera and the center point).</p>
<p><div class="fragment"><pre class="fragment">
    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> keyTyped(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c, modifier m, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y)
    {
        <span class="keywordflow">if</span> (c == 27) {
            ::exit(0);
        }
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
    }

    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> specialKey(key k, modifier m, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y)
    {
        <span class="keywordflow">switch</span> (k) {
        <span class="keywordflow">case</span> KEY_F5:
            manager-&gt;getResourceManager()-&gt;updateResources();
            <span class="keywordflow">break</span>;
        <span class="keywordflow">default</span>:
            <span class="keywordflow">break</span>;
        }
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
    }
</pre></div></p>
<p>The keyTyped and specialKey method handle keyboard events. Here they simply stop the program when ESC (ASCII code 27) is pressed, and update the resources when F5 is pressed.</p>
<p><div class="fragment"><pre class="fragment">
    <span class="keywordtype">bool</span> valid(vec3d p) {
        <span class="keywordflow">return</span> abs(p.x) &lt; 1000.0 &amp;&amp; abs(p.y) &lt; 1000.0 &amp;&amp; abs(p.z) &lt; 1000.0;
    }

    <span class="keyword">static</span> static_ptr&lt;Window&gt; app;
};

static_ptr&lt;Window&gt; HelloWorld::app;

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])
{
    atexit(Object::exit);
    HelloWorld::app = <span class="keyword">new</span> HelloWorld();
    HelloWorld::app-&gt;start();
    <span class="keywordflow">return</span> 0;
}
</pre></div></p>
<p>The rest of the code simply declares a static instance of the HelloWorld window, creates this instance, and starts the event loop. The atexit call ensures that Object::exit is called when the application stops, in order to clean up everything before exiting.</p>
<h3><a class="anchor" id="sec-helloworld-res">
Resources</a></h3>
<p>The above code is fairly generic, and its result mainly depends on how the scene graph is defined. This scene graph is defined in the following "helloworld.xml" archive file:</p>
 <div class="fragment"><pre class="fragment">&lt;?xml version=<span class="stringliteral">&quot;1.0&quot;</span> ?&gt;
&lt;archive&gt;
    &lt;multithreadScheduler name=<span class="stringliteral">&quot;defaultScheduler&quot;</span> nthreads=<span class="stringliteral">&quot;3&quot;</span> fps=<span class="stringliteral">&quot;0&quot;</span>/&gt;
</pre></div></p>
<p>The first resource defined in this archive is the scheduler. Here it is a multithread scheduler using 3 threads (which is not really necessary here for such a simple example).</p>
<p><div class="fragment"><pre class="fragment">
    &lt;sequence name=<span class="stringliteral">&quot;cameraMethod&quot;</span>&gt;
        &lt;<span class="keywordflow">foreach</span> var=<span class="stringliteral">&quot;o&quot;</span> flag=<span class="stringliteral">&quot;dynamic&quot;</span> parallel=<span class="stringliteral">&quot;true&quot;</span>&gt;
            &lt;callMethod name=<span class="stringliteral">&quot;$o.update&quot;</span>/&gt;
        &lt;/<span class="keywordflow">foreach</span>&gt;
        &lt;<span class="keywordflow">foreach</span> var=<span class="stringliteral">&quot;o&quot;</span> flag=<span class="stringliteral">&quot;object&quot;</span> culling=<span class="stringliteral">&quot;true&quot;</span>&gt;
            &lt;callMethod name=<span class="stringliteral">&quot;$o.draw&quot;</span>/&gt;
        &lt;/<span class="keywordflow">foreach</span>&gt;
    &lt;/sequence&gt;
</pre></div></p>
<p>The second resource is the camera method, which defines how the whole scene must be rendered. Here this method calls the "update" method on each scene node having the "dynamic" flag, and then calls the "draw" method on each scene node having the "object" flag.</p>
<p><div class="fragment"><pre class="fragment">
    &lt;terrainNode name=<span class="stringliteral">&quot;myTerrain&quot;</span> size=<span class="stringliteral">&quot;500&quot;</span> zmin=<span class="stringliteral">&quot;-1&quot;</span> zmax=<span class="stringliteral">&quot;1&quot;</span> splitFactor=<span class="stringliteral">&quot;2&quot;</span> maxLevel=<span class="stringliteral">&quot;7&quot;</span>/&gt;
</pre></div></p>
<p>The third resource is the terrain. Here we define a terrain of size 500 (i.e. its bounding box will be [-500,500]x[-500,500]), whose altitudes are between -1 and 1, and which will be subdivided with a split factor of 2, up to the quadtree level 7 at most.</p>
<p><div class="fragment"><pre class="fragment">
    &lt;sequence name=<span class="stringliteral">&quot;updateTerrainMethod&quot;</span>&gt;
        &lt;updateTerrain name=<span class="stringliteral">&quot;this.terrain&quot;</span>/&gt;
    &lt;/sequence&gt;
</pre></div></p>
<p>The fourth resource is the "update" method for the scene node corresponding to the terrain. This method simply calls the <a class="el" href="classproland_1_1UpdateTerrainTask.html" title="An AbstractTask to update a terrain quadtree.">proland::UpdateTerrainTask</a>, which subdivides the terrain quadtree based on the current camera position. The terrain is supposed to be defined by the "terrain" field of the scene node on which this method is called.</p>
<p><div class="fragment"><pre class="fragment">
    &lt;sequence name=<span class="stringliteral">&quot;drawTerrainMethod&quot;</span>&gt;
        &lt;setProgram&gt;
            &lt;module name=<span class="stringliteral">&quot;this.material&quot;</span>/&gt;
        &lt;/setProgram&gt;
        &lt;drawTerrain name=<span class="stringliteral">&quot;this.terrain&quot;</span> mesh=<span class="stringliteral">&quot;this.grid&quot;</span> culling=<span class="stringliteral">&quot;true&quot;</span>/&gt;
    &lt;/sequence&gt;
</pre></div></p>
<p>The fifth resource is the "draw" method for the scene node corresponding to the terrain. This method sets the shader whose id in the terrain scene node is "material" and then calls the <a class="el" href="classproland_1_1DrawTerrainTask.html" title="An AbstractTask to draw a terrain.">proland::DrawTerrainTask</a> to draw each visible leaf quad of the terrain, by drawing the mesh whose id in the terrain scene node is "grid" (using the previous shader). As above, the terrain is supposed to be defined by the "terrain" field of the scene node on which this method is called.</p>
<p><div class="fragment"><pre class="fragment">
    &lt;module name=<span class="stringliteral">&quot;terrainShader&quot;</span> version=<span class="stringliteral">&quot;330&quot;</span> source=<span class="stringliteral">&quot;terrainShader.glsl&quot;</span>/&gt;
</pre></div></p>
<p>This resource defines the shader that will be used to draw each terrain quad. It simply specifies the GLSL version of this shader, and the file that contain the shader source code.</p>
<p><div class="fragment"><pre class="fragment">
    &lt;node name=<span class="stringliteral">&quot;scene&quot;</span>&gt;
        &lt;node flags=<span class="stringliteral">&quot;camera&quot;</span>&gt;
            &lt;method <span class="keywordtype">id</span>=<span class="stringliteral">&quot;draw&quot;</span> value=<span class="stringliteral">&quot;cameraMethod&quot;</span>/&gt;
        &lt;/node&gt;

        &lt;node name=<span class="stringliteral">&quot;terrainNode&quot;</span> flags=<span class="stringliteral">&quot;object,dynamic&quot;</span>&gt;
            &lt;bounds xmin=<span class="stringliteral">&quot;-500&quot;</span> xmax=<span class="stringliteral">&quot;500&quot;</span> ymin=<span class="stringliteral">&quot;-500&quot;</span> ymax=<span class="stringliteral">&quot;500&quot;</span> zmin=<span class="stringliteral">&quot;-1&quot;</span> zmax=<span class="stringliteral">&quot;1&quot;</span>/&gt;
            &lt;field <span class="keywordtype">id</span>=<span class="stringliteral">&quot;terrain&quot;</span> value=<span class="stringliteral">&quot;myTerrain&quot;</span>/&gt;
            &lt;mesh <span class="keywordtype">id</span>=<span class="stringliteral">&quot;grid&quot;</span> value=<span class="stringliteral">&quot;quad.mesh&quot;</span>/&gt;
            &lt;method <span class="keywordtype">id</span>=<span class="stringliteral">&quot;update&quot;</span> value=<span class="stringliteral">&quot;updateTerrainMethod&quot;</span>/&gt;
            &lt;method <span class="keywordtype">id</span>=<span class="stringliteral">&quot;draw&quot;</span> value=<span class="stringliteral">&quot;drawTerrainMethod&quot;</span>/&gt;
            &lt;module <span class="keywordtype">id</span>=<span class="stringliteral">&quot;material&quot;</span> value=<span class="stringliteral">&quot;terrainShader&quot;</span>/&gt;
        &lt;/node&gt;
    &lt;/node&gt;
&lt;/archive&gt;
</pre></div></p>
<p>Finally the last resource defines the scene graph, using the previously defined resources (resource can in fact be defined in any order). This scene graph contains only two nodes. The first one is the camera node, which only contains one method, the one to draw the scene (defined above). The second node corresponds to the terrain. It has two flags, "object" and "dynamic" (cf the definition of the camera method). Its bounding box is defined, consistently with the terrain size (see above). The "terrain" field required by the updateTerrainMethod and drawTerrainMethod methods is set to the "myTerrain" terrain, defined above. The "grid" mesh required by the drawTerrainMethod method is set to the mesh defined in the "quad.mesh" file. Similarly, the "material" shader required by the drawTerrainMethod is set to the "terrainShader" module defined above. Finally the "draw" and "update" methods called by the camera method are set to the "drawTerrainMethod" and "updateTerrainMethod" defined above.</p>
<p>In order to complete the scene graph description, we simply need to provide the "quad.mesh" and "terrainShader.glsl" files. The first one is very simple:</p>
<div class="fragment"><pre class="fragment">0 1 0 1 0 0
trianglestrip
1
0 3 <span class="keywordtype">float</span> <span class="keyword">false</span>
4
0 0 0
1 0 0
0 1 0
1 1 0
0
</pre></div><p>It specifies a mesh whose bounding box is [0,1]x[0,1]x[0,0], made of triangle strips, whose vertices have a single attribute, made of 3 unnormalized floats. The 4 vertices are then specified, and the last 0 indicates that this mesh is not indexed. In fact it is a simple quad made of two triangles.</p>
<p>The terrain shader is also quite simple:</p>
 <div class="fragment"><pre class="fragment">uniform <span class="keyword">struct </span>{
    vec4 offset;
    vec4 camera;
    vec2 blending;
    mat4 localToScreen;
} deformation;

<span class="preprocessor">#ifdef _VERTEX_</span>
<span class="preprocessor"></span>
layout(location=0) in vec3 vertex;
out vec4 p;

<span class="keywordtype">void</span> main() {
    p = vec4(vertex.xy * deformation.offset.z + deformation.offset.xy, 0.0, 1.0);
    gl_Position = deformation.localToScreen * p;
}

<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="preprocessor">#ifdef _FRAGMENT_</span>

in vec4 p;
layout(location=0) out vec4 data;

<span class="keywordtype">void</span> main() {
    data = vec4(vec3(0.2 + 0.2 * sin(0.1 * length(p.xy))), 1.0);
    data.r += mod(dot(floor(deformation.offset.xy / deformation.offset.z + 0.5), vec2(1.0)), 2.0);
}

<span class="preprocessor">#endif</span>
</pre></div></p>
<p>The deformation uniforms are set by the <a class="el" href="classproland_1_1DrawTerrainTask.html" title="An AbstractTask to draw a terrain.">proland::DrawTerrainTask</a> before drawing each terrain quad. Here we only need the "offset" and "localToScreen" values. The "offset" value indicates how the [0,1]x[0,1] vertex coordinates must be transformed to get the terrain physical coordinates for this quad. The "localToScreen" matrix transforms these physical coordinates to screen coordinates. Both uniforms are used in the vertex shader to compute gl_Position. The fragment shader is a simple "procedural shader" based on the physical coordinates p output by the vertex shader. The last line produces a "checkerboard pattern" to easily see the terrain quads, i.e, to show how the terrain quadtree is subdivided when the camera moves. </p>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Sat May 12 09:41:36 2012 for proland by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
