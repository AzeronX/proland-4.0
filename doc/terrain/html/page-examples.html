<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>proland: Examples</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="page-examples">Examples </a></h1> 
<div class="mainpage">
<p>The following examples show how the Proland terrain plugin producers can be used. Since each example builds upon the previous ones, you should read them in order.</p>
<ul>
<li>
<a class="el" href="page-examples.html#sec-terrain1">Terrain1 example</a> </li>
<li>
<a class="el" href="page-examples.html#sec-terrain2">Terrain2 example</a> </li>
<li>
<a class="el" href="page-examples.html#sec-terrain3">Terrain3 example</a> </li>
<li>
<a class="el" href="page-examples.html#sec-terrain4">Terrain4 example</a> </li>
<li>
<a class="el" href="page-examples.html#sec-terrain5">Terrain5 example</a> </li>
<li>
<a class="el" href="page-examples.html#sec-preprocess">Preprocess example</a> </li>
</ul>
<p>Exercises (using also the edit, atmo and ocean plugins). </p>
<ul>
<li>
<a class="el" href="page-examples.html#sec-exercise1">Exercise 1</a> </li>
<li>
<a class="el" href="page-examples.html#sec-exercise2">Exercise 2</a> </li>
<li>
<a class="el" href="page-examples.html#sec-exercise3">Exercise 3</a> </li>
<li>
<a class="el" href="page-examples.html#sec-exercise4">Exercise 4</a> </li>
<li>
<a class="el" href="page-examples.html#sec-exercise5">Exercise 5</a> </li>
</ul>
<h2><a class="anchor" id="sec-terrain1">
Terrain1 example</a></h2>
 
<img src="terrain1.png"><br/>
 <!--  <div align="center">
<img src="terrain1.png" alt="terrain1.png"/>
</div>
  --> <p>This example extends the helloworld example from the Proland Core documentation with the use of an elevation producer and of a normal producer. The HelloWorld.cpp file is exactly the same (except the constants related to the terrain size). The only differences are in the resource files, thereby showing that the previous C++ code is in fact quite generic.</p>
<p>The first differences are in the "helloworld.xml" file:</p>
 <div class="fragment"><pre class="fragment">    &lt;tileCache name=<span class="stringliteral">&quot;groundElevations&quot;</span> scheduler=<span class="stringliteral">&quot;defaultScheduler&quot;</span>&gt;
        &lt;gpuTileStorage tileSize=<span class="stringliteral">&quot;101&quot;</span> nTiles=<span class="stringliteral">&quot;512&quot;</span>
            internalformat=<span class="stringliteral">&quot;RGB32F&quot;</span> format=<span class="stringliteral">&quot;RGB&quot;</span> type=<span class="stringliteral">&quot;FLOAT&quot;</span> min=<span class="stringliteral">&quot;LINEAR&quot;</span> mag=<span class="stringliteral">&quot;LINEAR&quot;</span>/&gt;
    &lt;/tileCache&gt;
    &lt;elevationProducer name=<span class="stringliteral">&quot;groundElevations1&quot;</span> cache=<span class="stringliteral">&quot;groundElevations&quot;</span>
        noise=<span class="stringliteral">&quot;-140,-100,-15,-8,5,2.5,1.5,1,0.5,0.25,0.1,0.05&quot;</span>/&gt;

    &lt;tileCache name=<span class="stringliteral">&quot;groundNormals&quot;</span> scheduler=<span class="stringliteral">&quot;defaultScheduler&quot;</span>&gt;
        &lt;gpuTileStorage tileSize=<span class="stringliteral">&quot;97&quot;</span> nTiles=<span class="stringliteral">&quot;512&quot;</span>
            internalformat=<span class="stringliteral">&quot;RG8&quot;</span> format=<span class="stringliteral">&quot;RG&quot;</span> type=<span class="stringliteral">&quot;FLOAT&quot;</span> min=<span class="stringliteral">&quot;LINEAR&quot;</span> mag=<span class="stringliteral">&quot;LINEAR&quot;</span>/&gt;
    &lt;/tileCache&gt;
    &lt;normalProducer name=<span class="stringliteral">&quot;groundNormals1&quot;</span> cache=<span class="stringliteral">&quot;groundNormals&quot;</span> elevations=<span class="stringliteral">&quot;groundElevations1&quot;</span>/&gt;
</pre></div></p>
<p>First a tile cache is defined to store up to 512 elevation tiles of size 101x101 (including borders). This cache is then used to define an elevation producer. This producer does not have any associated residual producer. It will therefore generate a random fractal terrain, based on the provided noise amplitudes. The upsampling and add program is not specified, and is therefore equal to its default value, "upsampleShader;". Then another tile cache is defined to store up to 512 normal tiles of size 97x97, with only two 8 bits components per pixel. This cache is then used to define a normal producer, based on the previous elevation producer.</p>
<p><div class="fragment"><pre class="fragment">    &lt;sequence name=<span class="stringliteral">&quot;updateTerrainMethod&quot;</span>&gt;
        &lt;updateTerrain name=<span class="stringliteral">&quot;this.terrain&quot;</span>/&gt;
        &lt;updateTileSamplers name=<span class="stringliteral">&quot;this.terrain&quot;</span>/&gt;
    &lt;/sequence&gt;
</pre></div></p>
<p>The updateTerrainMethod is also modified, in order to add a call to the proland::UpdateTileSamplersTask. This task produces the tiles for new terrain quads, if any, generated by the update terrain task. It also releases the tiles for deleted terrain quads, if any, so that they can be evicted from the cache if necessary.</p>
<p><div class="fragment"><pre class="fragment">        &lt;node name=<span class="stringliteral">&quot;terrainNode&quot;</span> flags=<span class="stringliteral">&quot;object,dynamic&quot;</span>&gt;
            &lt;bounds xmin=<span class="stringliteral">&quot;-50000&quot;</span> xmax=<span class="stringliteral">&quot;50000&quot;</span> ymin=<span class="stringliteral">&quot;-50000&quot;</span> ymax=<span class="stringliteral">&quot;50000&quot;</span> zmin=<span class="stringliteral">&quot;0&quot;</span> zmax=<span class="stringliteral">&quot;5000&quot;</span>/&gt;
            &lt;field <span class="keywordtype">id</span>=<span class="stringliteral">&quot;terrain&quot;</span> value=<span class="stringliteral">&quot;terrain&quot;</span>/&gt;
            &lt;tileSamplerZ <span class="keywordtype">id</span>=<span class="stringliteral">&quot;elevation&quot;</span> sampler=<span class="stringliteral">&quot;elevationSampler&quot;</span> producer=<span class="stringliteral">&quot;groundElevations1&quot;</span> storeInvisible=<span class="stringliteral">&quot;false&quot;</span>/&gt;
            &lt;tileSampler <span class="keywordtype">id</span>=<span class="stringliteral">&quot;fnormal&quot;</span> sampler=<span class="stringliteral">&quot;fragmentNormalSampler&quot;</span> producer=<span class="stringliteral">&quot;groundNormals1&quot;</span> storeParent=<span class="stringliteral">&quot;false&quot;</span> storeInvisible=<span class="stringliteral">&quot;false&quot;</span>/&gt;
            &lt;mesh <span class="keywordtype">id</span>=<span class="stringliteral">&quot;grid&quot;</span> value=<span class="stringliteral">&quot;quad.mesh&quot;</span>/&gt;
            &lt;method <span class="keywordtype">id</span>=<span class="stringliteral">&quot;update&quot;</span> value=<span class="stringliteral">&quot;updateTerrainMethod&quot;</span>/&gt;
            &lt;method <span class="keywordtype">id</span>=<span class="stringliteral">&quot;draw&quot;</span> value=<span class="stringliteral">&quot;drawTerrainMethod&quot;</span>/&gt;
            &lt;module <span class="keywordtype">id</span>=<span class="stringliteral">&quot;material&quot;</span> value=<span class="stringliteral">&quot;terrainShader&quot;</span>/&gt;
        &lt;/node&gt;
</pre></div></p>
<p>Finally the terrain node is also modified, in order to associate tile samplers to the terrain. These two tile samplers are linked to the previously defined producers. The corresponding GLSL uniform names are declared in the "sampler" attributes.</p>
<p>The other resource files are modified as well, compared to the helloworld example. The "quad.mesh" now contains a grid made of 24x24 quads. The "terrainShader.glsl" now contains two new uniforms, "elevationSampler" and "fragmentNormalSampler", of type "samplerTile" defined at the beginning of the shader. They are used in the vertex and fragment shaders via the "textureTile" function (also defined at the begining of the shader), which is very similar to a builtin GLSL "texture" function call. The "camera" and "blending" uniforms are now used to compute a continuous level of details for elevations in the vertex shader, as explained in sec-quadblend.</p>
<p>Finally two new shaders are defined, to produce the elevation and normal tiles on GPU. These are basic versions of these shaders, only applicable for non spherical terrains. The upsampling filter can be found in the upsampleMatrix array in "upsampleShader.glsl".</p>
<dl class="note"><dt><b>Note:</b></dt><dd>this simple example is sufficient to illustrate the automatic update of produced data when inputs and/or producing algorithms are changed. While the example is running, edit the values in the "noise" attribute of the elevationProducer resource in "helloworld.xml" with a text editor. When you select the example window again you should immediately see the effect of these changes on the terrain (if not press F5). You can also edit "terrainShader.glsl" and "upsampleShader.glsl" while the program is running, and see the effects of these changes immediately on the terrain. For instance you can comment the line 52 in "terrainShader" ("data = 
vec4(0.0, 0.0, 0.5, 1.0);") to disable the specific rendering of "ocean" parts. You can also change the line 97 in "upsampleShader" with "data = vec4(zf, zc, zf, 0.0);", in order to disable the flattening of "ocean" parts.</dd></dl>
<h2><a class="anchor" id="sec-terrain2">
Terrain2 example</a></h2>
 
<img src="terrain2.png"><br/>
 <!--  <div align="center">
<img src="terrain2.png" alt="terrain2.png"/>
</div>
  --> <p>This example is very similar to the previous one, but adapted to the case of a spherical terrain, i.e., a planet. Here again the HelloWorld.cpp file is almost exactly the same as in the previous example. The only difference is that the TerrainViewController is replaced with a PlanetViewController.</p>
<p>The main differences are in the definition of the scene graph, in the "helloworld.xml" file. The tile caches for the elevation and normal tiles are unchanged, but the producers using these caches are modified. First, instead of one elevation and one normal producer, we define six elevation producers and six normal producers (one per face of a cube enclosing the sphere):</p>
 <div class="fragment"><pre class="fragment">    &lt;tileCache name=<span class="stringliteral">&quot;groundElevations&quot;</span> scheduler=<span class="stringliteral">&quot;defaultScheduler&quot;</span>&gt;
        &lt;gpuTileStorage tileSize=<span class="stringliteral">&quot;101&quot;</span> nTiles=<span class="stringliteral">&quot;512&quot;</span>
            internalformat=<span class="stringliteral">&quot;RGB32F&quot;</span> format=<span class="stringliteral">&quot;RGB&quot;</span> type=<span class="stringliteral">&quot;FLOAT&quot;</span> min=<span class="stringliteral">&quot;LINEAR&quot;</span> mag=<span class="stringliteral">&quot;LINEAR&quot;</span>/&gt;
    &lt;/tileCache&gt;
    &lt;elevationProducer name=<span class="stringliteral">&quot;groundElevations1&quot;</span> cache=<span class="stringliteral">&quot;groundElevations&quot;</span>
        noise=<span class="stringliteral">&quot;-3250,-1590,-1125,-795,-561,-397,-140,-100,15,8,5,2.5,1.5,1,0.5,0.25,0.1,0.05&quot;</span>/&gt;
    &lt;elevationProducer name=<span class="stringliteral">&quot;groundElevations2&quot;</span> cache=<span class="stringliteral">&quot;groundElevations&quot;</span>
        noise=<span class="stringliteral">&quot;-3250,-1590,-1125,-795,-561,-397,-140,-100,15,8,5,2.5,1.5,1,0.5,0.25,0.1,0.05&quot;</span>/&gt;
    &lt;elevationProducer name=<span class="stringliteral">&quot;groundElevations3&quot;</span> cache=<span class="stringliteral">&quot;groundElevations&quot;</span>
        noise=<span class="stringliteral">&quot;-3250,-1590,-1125,-795,-561,-397,-140,-100,15,8,5,2.5,1.5,1,0.5,0.25,0.1,0.05&quot;</span>/&gt;
    &lt;elevationProducer name=<span class="stringliteral">&quot;groundElevations4&quot;</span> cache=<span class="stringliteral">&quot;groundElevations&quot;</span>
        noise=<span class="stringliteral">&quot;-3250,-1590,-1125,-795,-561,-397,-140,-100,15,8,5,2.5,1.5,1,0.5,0.25,0.1,0.05&quot;</span>/&gt;
    &lt;elevationProducer name=<span class="stringliteral">&quot;groundElevations5&quot;</span> cache=<span class="stringliteral">&quot;groundElevations&quot;</span>
        noise=<span class="stringliteral">&quot;-3250,-1590,-1125,-795,-561,-397,-140,-100,15,8,5,2.5,1.5,1,0.5,0.25,0.1,0.05&quot;</span>/&gt;
    &lt;elevationProducer name=<span class="stringliteral">&quot;groundElevations6&quot;</span> cache=<span class="stringliteral">&quot;groundElevations&quot;</span>
        noise=<span class="stringliteral">&quot;-3250,-1590,-1125,-795,-561,-397,-140,-100,15,8,5,2.5,1.5,1,0.5,0.25,0.1,0.05&quot;</span>/&gt;

    &lt;tileCache name=<span class="stringliteral">&quot;groundNormals&quot;</span> scheduler=<span class="stringliteral">&quot;defaultScheduler&quot;</span>&gt;
        &lt;gpuTileStorage tileSize=<span class="stringliteral">&quot;97&quot;</span> nTiles=<span class="stringliteral">&quot;512&quot;</span>
            internalformat=<span class="stringliteral">&quot;RG8&quot;</span> format=<span class="stringliteral">&quot;RG&quot;</span> type=<span class="stringliteral">&quot;FLOAT&quot;</span> min=<span class="stringliteral">&quot;LINEAR&quot;</span> mag=<span class="stringliteral">&quot;LINEAR&quot;</span>/&gt;
    &lt;/tileCache&gt;
    &lt;normalProducer name=<span class="stringliteral">&quot;groundNormals1&quot;</span> cache=<span class="stringliteral">&quot;groundNormals&quot;</span> elevations=<span class="stringliteral">&quot;groundElevations1&quot;</span> deform=<span class="stringliteral">&quot;sphere&quot;</span>/&gt;
    &lt;normalProducer name=<span class="stringliteral">&quot;groundNormals2&quot;</span> cache=<span class="stringliteral">&quot;groundNormals&quot;</span> elevations=<span class="stringliteral">&quot;groundElevations2&quot;</span> deform=<span class="stringliteral">&quot;sphere&quot;</span>/&gt;
    &lt;normalProducer name=<span class="stringliteral">&quot;groundNormals3&quot;</span> cache=<span class="stringliteral">&quot;groundNormals&quot;</span> elevations=<span class="stringliteral">&quot;groundElevations3&quot;</span> deform=<span class="stringliteral">&quot;sphere&quot;</span>/&gt;
    &lt;normalProducer name=<span class="stringliteral">&quot;groundNormals4&quot;</span> cache=<span class="stringliteral">&quot;groundNormals&quot;</span> elevations=<span class="stringliteral">&quot;groundElevations4&quot;</span> deform=<span class="stringliteral">&quot;sphere&quot;</span>/&gt;
    &lt;normalProducer name=<span class="stringliteral">&quot;groundNormals5&quot;</span> cache=<span class="stringliteral">&quot;groundNormals&quot;</span> elevations=<span class="stringliteral">&quot;groundElevations5&quot;</span> deform=<span class="stringliteral">&quot;sphere&quot;</span>/&gt;
    &lt;normalProducer name=<span class="stringliteral">&quot;groundNormals6&quot;</span> cache=<span class="stringliteral">&quot;groundNormals&quot;</span> elevations=<span class="stringliteral">&quot;groundElevations6&quot;</span> deform=<span class="stringliteral">&quot;sphere&quot;</span>/&gt;
</pre></div></p>
<p>The six elevation producers share the same elevation tile cache, and similarly for the normal producers. The normal producers have the <code>deform="sphere"</code> attribute, indicating that normals will be mapped on a sphere (this is important to compute normals correctly).</p>
<p><div class="fragment"><pre class="fragment">    &lt;terrainNode name=<span class="stringliteral">&quot;earth1&quot;</span> size=<span class="stringliteral">&quot;6360000&quot;</span> zmin=<span class="stringliteral">&quot;0&quot;</span> zmax=<span class="stringliteral">&quot;10000&quot;</span> deform=<span class="stringliteral">&quot;sphere&quot;</span> splitFactor=<span class="stringliteral">&quot;2&quot;</span> maxLevel=<span class="stringliteral">&quot;20&quot;</span>/&gt;
    &lt;terrainNode name=<span class="stringliteral">&quot;earth2&quot;</span> size=<span class="stringliteral">&quot;6360000&quot;</span> zmin=<span class="stringliteral">&quot;0&quot;</span> zmax=<span class="stringliteral">&quot;10000&quot;</span> deform=<span class="stringliteral">&quot;sphere&quot;</span> splitFactor=<span class="stringliteral">&quot;2&quot;</span> maxLevel=<span class="stringliteral">&quot;20&quot;</span>/&gt;
    &lt;terrainNode name=<span class="stringliteral">&quot;earth3&quot;</span> size=<span class="stringliteral">&quot;6360000&quot;</span> zmin=<span class="stringliteral">&quot;0&quot;</span> zmax=<span class="stringliteral">&quot;10000&quot;</span> deform=<span class="stringliteral">&quot;sphere&quot;</span> splitFactor=<span class="stringliteral">&quot;2&quot;</span> maxLevel=<span class="stringliteral">&quot;20&quot;</span>/&gt;
    &lt;terrainNode name=<span class="stringliteral">&quot;earth4&quot;</span> size=<span class="stringliteral">&quot;6360000&quot;</span> zmin=<span class="stringliteral">&quot;0&quot;</span> zmax=<span class="stringliteral">&quot;10000&quot;</span> deform=<span class="stringliteral">&quot;sphere&quot;</span> splitFactor=<span class="stringliteral">&quot;2&quot;</span> maxLevel=<span class="stringliteral">&quot;20&quot;</span>/&gt;
    &lt;terrainNode name=<span class="stringliteral">&quot;earth5&quot;</span> size=<span class="stringliteral">&quot;6360000&quot;</span> zmin=<span class="stringliteral">&quot;0&quot;</span> zmax=<span class="stringliteral">&quot;10000&quot;</span> deform=<span class="stringliteral">&quot;sphere&quot;</span> splitFactor=<span class="stringliteral">&quot;2&quot;</span> maxLevel=<span class="stringliteral">&quot;20&quot;</span>/&gt;
    &lt;terrainNode name=<span class="stringliteral">&quot;earth6&quot;</span> size=<span class="stringliteral">&quot;6360000&quot;</span> zmin=<span class="stringliteral">&quot;0&quot;</span> zmax=<span class="stringliteral">&quot;10000&quot;</span> deform=<span class="stringliteral">&quot;sphere&quot;</span> splitFactor=<span class="stringliteral">&quot;2&quot;</span> maxLevel=<span class="stringliteral">&quot;20&quot;</span>/&gt;
</pre></div></p>
<p>Similarly, instead of one terrain, we now have six, with a spherical deformation.</p>
<p><div class="fragment"><pre class="fragment">        &lt;node name=<span class="stringliteral">&quot;earth1&quot;</span> flags=<span class="stringliteral">&quot;object,dynamic&quot;</span>&gt;
            &lt;bounds xmin=<span class="stringliteral">&quot;-4504270&quot;</span> xmax=<span class="stringliteral">&quot;4504270&quot;</span> ymin=<span class="stringliteral">&quot;-4504270&quot;</span> ymax=<span class="stringliteral">&quot;4504270&quot;</span> zmin=<span class="stringliteral">&quot;4494270&quot;</span> zmax=<span class="stringliteral">&quot;6370000&quot;</span>/&gt;
            &lt;field <span class="keywordtype">id</span>=<span class="stringliteral">&quot;terrain&quot;</span> value=<span class="stringliteral">&quot;earth1&quot;</span>/&gt;
            &lt;tileSamplerZ <span class="keywordtype">id</span>=<span class="stringliteral">&quot;elevation&quot;</span> sampler=<span class="stringliteral">&quot;elevationSampler&quot;</span> producer=<span class="stringliteral">&quot;groundElevations1&quot;</span> storeInvisible=<span class="stringliteral">&quot;false&quot;</span>/&gt;
            &lt;tileSampler <span class="keywordtype">id</span>=<span class="stringliteral">&quot;fnormal&quot;</span> sampler=<span class="stringliteral">&quot;fragmentNormalSampler&quot;</span> producer=<span class="stringliteral">&quot;groundNormals1&quot;</span> storeInvisible=<span class="stringliteral">&quot;false&quot;</span>/&gt;
            &lt;mesh <span class="keywordtype">id</span>=<span class="stringliteral">&quot;grid&quot;</span> value=<span class="stringliteral">&quot;quad.mesh&quot;</span>/&gt;
            &lt;method <span class="keywordtype">id</span>=<span class="stringliteral">&quot;update&quot;</span> value=<span class="stringliteral">&quot;updateTerrainMethod&quot;</span>/&gt;
            &lt;method <span class="keywordtype">id</span>=<span class="stringliteral">&quot;draw&quot;</span> value=<span class="stringliteral">&quot;drawTerrainMethod&quot;</span>/&gt;
            &lt;module <span class="keywordtype">id</span>=<span class="stringliteral">&quot;material&quot;</span> value=<span class="stringliteral">&quot;terrainShader&quot;</span>/&gt;
        &lt;/node&gt;

        &lt;node name=<span class="stringliteral">&quot;earth2&quot;</span> flags=<span class="stringliteral">&quot;object,dynamic&quot;</span>&gt;
            &lt;rotatex angle=<span class="stringliteral">&quot;90&quot;</span>/&gt;
            &lt;bounds xmin=<span class="stringliteral">&quot;-4504270&quot;</span> xmax=<span class="stringliteral">&quot;4504270&quot;</span> ymin=<span class="stringliteral">&quot;-4504270&quot;</span> ymax=<span class="stringliteral">&quot;4504270&quot;</span> zmin=<span class="stringliteral">&quot;4494270&quot;</span> zmax=<span class="stringliteral">&quot;6370000&quot;</span>/&gt;
            &lt;field <span class="keywordtype">id</span>=<span class="stringliteral">&quot;terrain&quot;</span> value=<span class="stringliteral">&quot;earth2&quot;</span>/&gt;
            &lt;tileSamplerZ <span class="keywordtype">id</span>=<span class="stringliteral">&quot;elevation&quot;</span> sampler=<span class="stringliteral">&quot;elevationSampler&quot;</span> producer=<span class="stringliteral">&quot;groundElevations2&quot;</span> storeInvisible=<span class="stringliteral">&quot;false&quot;</span>/&gt;
            &lt;tileSampler <span class="keywordtype">id</span>=<span class="stringliteral">&quot;fnormal&quot;</span> sampler=<span class="stringliteral">&quot;fragmentNormalSampler&quot;</span> producer=<span class="stringliteral">&quot;groundNormals2&quot;</span> storeInvisible=<span class="stringliteral">&quot;false&quot;</span>/&gt;
            &lt;mesh <span class="keywordtype">id</span>=<span class="stringliteral">&quot;grid&quot;</span> value=<span class="stringliteral">&quot;quad.mesh&quot;</span>/&gt;
            &lt;method <span class="keywordtype">id</span>=<span class="stringliteral">&quot;update&quot;</span> value=<span class="stringliteral">&quot;updateTerrainMethod&quot;</span>/&gt;
            &lt;method <span class="keywordtype">id</span>=<span class="stringliteral">&quot;draw&quot;</span> value=<span class="stringliteral">&quot;drawTerrainMethod&quot;</span>/&gt;
            &lt;module <span class="keywordtype">id</span>=<span class="stringliteral">&quot;material&quot;</span> value=<span class="stringliteral">&quot;terrainShader&quot;</span>/&gt;
        &lt;/node&gt;
</pre></div></p>
<p>Finally, we also have six scene nodes, corresponding to the six terrains (here only the first two are shown). Each node is defined as in the previous example. The only difference is that some nodes are rotated to orient them like the six faces of a cube enclosing the sphere (no translation is necessary, because it is handled by the spherical deformation).</p>
<p>The "terrainShader.glsl" is also modified, compared to the previous example. First there are more uniforms related to the terrain deformation, because we are using here a spherical deformation (instead of the identity deformation, i.e, no deformation). The vertex shader is also more complex. It uses these new uniforms to compute the screen projection of the terrain vertices as described in sec-spheredeform. Also the fragment shader converts the normal to world space with the "deformation.tangentFrameToWorld" matrix before doing lighting computation with it (it also uses a slighty more elaborate procedural method to compute the terrain color, but there is nothing specific to spherical terrain here).</p>
<p>The "upsamplerShader.glsl" is also more complex than in the previous example. Indeed, it modulates the noise amplitude based on the local terrain slope and curvature. For this, it first computes the slope and the curvature, using "filters" defined in the slopexMatrix, slopeyMatrix and curvatureMatrix arrays. It then combines these values to compute a noise amplitude factor in noiseAmp. The effect of this additional code, producing non-uniform noise, can be seen below (left: non-uniform noise, right: uniform noise).</p>
 
<center>
<img src="terrain2-a.png"> <img src="terrain2-b.png"><br/>
</center>
 <!--  <div align="center">
<img src="terrain2-a.png" alt="terrain2-a.png"/>
</div>
 <div align="center">
<img src="terrain2-b.png" alt="terrain2-b.png"/>
</div>
  --> <dl class="note"><dt><b>Note:</b></dt><dd>you can replace line 141 in "upsampleShader.glsl" with "noiseAmp = 1.0;", while the program is running, to immediately see the effect of this modulation factor based on the local slope and curvature. You can also tune the constants in the original expression to see their effect on the produced terrain.</dd></dl>
<p>Finally the "normalShader.glsl" is also more complex that in the previous example, because of the spherical deformation. In order to compute a normal from 4 vertices it first finds the world coordinates of these vertices after deformation (using the same code as in the vertex shader of "terrainShader.glsl", and described in sec-spheredeform). It then computes the normal in world space from these transformed points, and finally outputs it value in tangent space.</p>
<h2><a class="anchor" id="sec-terrain3">
Terrain3 example</a></h2>
 
<img src="terrain3.png"><br/>
 <!--  <div align="center">
<img src="terrain3.png" alt="terrain3.png"/>
</div>
  --> <p>This example extends the "terrain1" example in two ways: it adds an ortho producer to get a fractal terrain texture, and it also improves the user interface (use of proland::BasicViewHandler for a better interactive navigation in the terrain, display of the logs and of the framerate on screen, use of tweakbars).</p>
<h3><a class="anchor" id="sec-terrain3-tex">
Ortho producer</a></h3>
<p>Compared to the "terrain1" example, the "helloworld.xml" file defines a new tile cache for the terrain texture:</p>
 <div class="fragment"><pre class="fragment">    &lt;tileCache name=<span class="stringliteral">&quot;groundOrthoGpu&quot;</span> scheduler=<span class="stringliteral">&quot;defaultScheduler&quot;</span>&gt;
        &lt;gpuTileStorage tileSize=<span class="stringliteral">&quot;196&quot;</span> nTiles=<span class="stringliteral">&quot;512&quot;</span>
            internalformat=<span class="stringliteral">&quot;RGB8&quot;</span> format=<span class="stringliteral">&quot;RGB&quot;</span> type=<span class="stringliteral">&quot;UNSIGNED_BYTE&quot;</span> min=<span class="stringliteral">&quot;LINEAR_MIPMAP_LINEAR&quot;</span> mag=<span class="stringliteral">&quot;LINEAR&quot;</span>
            anisotropy=<span class="stringliteral">&quot;16&quot;</span>/&gt;
    &lt;/tileCache&gt;
    &lt;orthoProducer name=<span class="stringliteral">&quot;groundOrthoGpu1&quot;</span> cache=<span class="stringliteral">&quot;groundOrthoGpu&quot;</span>
        hsv=<span class="stringliteral">&quot;true&quot;</span> rnoise=<span class="stringliteral">&quot;60,150,20&quot;</span> cnoise=<span class="stringliteral">&quot;70,80,100&quot;</span>
        noise=<span class="stringliteral">&quot;255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255&quot;</span>/&gt;
</pre></div></p>
<p>This cache can store up to 512 tiles of size 196x196 (including borders), with RGB8 pixel format. It is used in the ortho producer defined just after. This producer does not have an associated OrthoCPUProducer producing color residuals. It will therefore produce a fractal texture based on the provided noise amplitudes and colors, specified in HSV space (as opposed to RGB). The upsampling and add shader used by the producer is not specified, so it is equal to its default value "upsampleOrthoShader;". This shader is provided in the "upsampleOrthoShader.glsl" file (the upsampling filter coefficients, presented in <a class="el" href="index.html#sec-ortho">Ortho producer</a>, can be found in the "masks" array).</p>
<p><div class="fragment"><pre class="fragment">        &lt;node name=<span class="stringliteral">&quot;terrainNode&quot;</span> flags=<span class="stringliteral">&quot;object,dynamic&quot;</span>&gt;
            &lt;bounds xmin=<span class="stringliteral">&quot;-50000&quot;</span> xmax=<span class="stringliteral">&quot;50000&quot;</span> ymin=<span class="stringliteral">&quot;-50000&quot;</span> ymax=<span class="stringliteral">&quot;50000&quot;</span> zmin=<span class="stringliteral">&quot;0&quot;</span> zmax=<span class="stringliteral">&quot;5000&quot;</span>/&gt;
            &lt;field <span class="keywordtype">id</span>=<span class="stringliteral">&quot;terrain&quot;</span> value=<span class="stringliteral">&quot;terrain&quot;</span>/&gt;
            &lt;tileSamplerZ <span class="keywordtype">id</span>=<span class="stringliteral">&quot;elevation&quot;</span> sampler=<span class="stringliteral">&quot;elevationSampler&quot;</span> producer=<span class="stringliteral">&quot;groundElevations1&quot;</span> storeInvisible=<span class="stringliteral">&quot;false&quot;</span>/&gt;
            &lt;tileSampler <span class="keywordtype">id</span>=<span class="stringliteral">&quot;fnormal&quot;</span> sampler=<span class="stringliteral">&quot;fragmentNormalSampler&quot;</span> producer=<span class="stringliteral">&quot;groundNormals1&quot;</span> storeParent=<span class="stringliteral">&quot;false&quot;</span> storeInvisible=<span class="stringliteral">&quot;false&quot;</span>/&gt;
            &lt;tileSampler <span class="keywordtype">id</span>=<span class="stringliteral">&quot;ortho&quot;</span> sampler=<span class="stringliteral">&quot;orthoSampler&quot;</span> producer=<span class="stringliteral">&quot;groundOrthoGpu1&quot;</span> storeParent=<span class="stringliteral">&quot;true&quot;</span> storeInvisible=<span class="stringliteral">&quot;false&quot;</span>/&gt;
            &lt;mesh <span class="keywordtype">id</span>=<span class="stringliteral">&quot;grid&quot;</span> value=<span class="stringliteral">&quot;quad.mesh&quot;</span>/&gt;
            &lt;method <span class="keywordtype">id</span>=<span class="stringliteral">&quot;update&quot;</span> value=<span class="stringliteral">&quot;updateTerrainMethod&quot;</span>/&gt;
            &lt;method <span class="keywordtype">id</span>=<span class="stringliteral">&quot;draw&quot;</span> value=<span class="stringliteral">&quot;drawTerrainMethod&quot;</span>/&gt;
            &lt;module <span class="keywordtype">id</span>=<span class="stringliteral">&quot;material&quot;</span> value=<span class="stringliteral">&quot;terrainShader&quot;</span>/&gt;
        &lt;/node&gt;
</pre></div></p>
<p>This ortho producer is used in a new tile sampler associated with the terrain, itself associated with the "orthoSampler" GLSL uniform in the terrain shader (see "terrainShader.glsl", which is almost the same as in the "terrain1" example).</p>
<dl class="note"><dt><b>Note:</b></dt><dd>you can edit the noise color and amplitudes in the ortho producer above, while the program is running, to immediately see their effect on the produced terrain texture.</dd></dl>
<h3><a class="anchor" id="sec-terrain3-ui">
User interface</a></h3>
<p>In this example the user interface is improved in several ways, compared to the "terrain1" example. We first add three overlays: one to display the framerate in the topleft corner of the window, another to display the logs in the bottomleft corner (press F1 to show and hide these logs), and a third one to display a tweakbar (click on the small box in the bottomleft corner to maximize this bar).</p>
<p>For this we add three new nodes in the scene graph, with an "overlay" flag, in the "helloworld.xml" file:</p>
 <div class="fragment"><pre class="fragment">        &lt;node flags=<span class="stringliteral">&quot;overlay&quot;</span>&gt;
            &lt;method <span class="keywordtype">id</span>=<span class="stringliteral">&quot;draw&quot;</span> value=<span class="stringliteral">&quot;drawTweakBarMethod&quot;</span>/&gt;
        &lt;/node&gt;
        &lt;node flags=<span class="stringliteral">&quot;overlay&quot;</span>&gt;
            &lt;method <span class="keywordtype">id</span>=<span class="stringliteral">&quot;draw&quot;</span> value=<span class="stringliteral">&quot;logMethod&quot;</span>/&gt;
        &lt;/node&gt;
        &lt;node flags=<span class="stringliteral">&quot;overlay&quot;</span>&gt;
            &lt;method <span class="keywordtype">id</span>=<span class="stringliteral">&quot;draw&quot;</span> value=<span class="stringliteral">&quot;infoMethod&quot;</span>/&gt;
        &lt;/node&gt;
</pre></div></p>
<p>Each node has a single draw method. These methods are defined by the following resources:</p>
 <div class="fragment"><pre class="fragment">    &lt;texture2D name=<span class="stringliteral">&quot;font&quot;</span> source=<span class="stringliteral">&quot;text.png&quot;</span> internalformat=<span class="stringliteral">&quot;R8&quot;</span> min=<span class="stringliteral">&quot;LINEAR_MIPMAP_LINEAR&quot;</span> mag=<span class="stringliteral">&quot;LINEAR&quot;</span>/&gt;

    &lt;font name=<span class="stringliteral">&quot;basicFont&quot;</span> tex=<span class="stringliteral">&quot;font&quot;</span> nRows=<span class="stringliteral">&quot;8&quot;</span> nCols=<span class="stringliteral">&quot;12&quot;</span> minChar=<span class="stringliteral">&quot;32&quot;</span> maxChar=<span class="stringliteral">&quot;127&quot;</span> invalidChar=<span class="stringliteral">&quot;63&quot;</span> charWidths=<span class="stringliteral">&quot;19&quot;</span>/&gt;

    &lt;module name=<span class="stringliteral">&quot;textShader&quot;</span> version=<span class="stringliteral">&quot;330&quot;</span> source=<span class="stringliteral">&quot;textShader.glsl&quot;</span>/&gt;

    &lt;showInfo name=<span class="stringliteral">&quot;infoMethod&quot;</span> x=<span class="stringliteral">&quot;4&quot;</span> y=<span class="stringliteral">&quot;4&quot;</span> maxLines=<span class="stringliteral">&quot;4&quot;</span> fontSize=<span class="stringliteral">&quot;24&quot;</span> font=<span class="stringliteral">&quot;basicFont&quot;</span> fontProgram=<span class="stringliteral">&quot;textShader;&quot;</span>/&gt;

    &lt;showLog name=<span class="stringliteral">&quot;logMethod&quot;</span> x=<span class="stringliteral">&quot;4&quot;</span> y=<span class="stringliteral">&quot;-4&quot;</span> maxLines=<span class="stringliteral">&quot;32&quot;</span> fontSize=<span class="stringliteral">&quot;16&quot;</span> font=<span class="stringliteral">&quot;basicFont&quot;</span> fontProgram=<span class="stringliteral">&quot;textShader;&quot;</span>/&gt;

    &lt;drawTweakBar name=<span class="stringliteral">&quot;drawTweakBarMethod&quot;</span>/&gt;
    &lt;tweakScene name=<span class="stringliteral">&quot;editScene&quot;</span> scene=<span class="stringliteral">&quot;scene&quot;</span> active=<span class="stringliteral">&quot;false&quot;</span>/&gt;

    &lt;tweakBarManager name=<span class="stringliteral">&quot;ui&quot;</span>&gt;
        &lt;editor <span class="keywordtype">id</span>=<span class="stringliteral">&quot;scene&quot;</span> bar=<span class="stringliteral">&quot;editScene&quot;</span> exclusive=<span class="stringliteral">&quot;false&quot;</span>/&gt;
    &lt;/tweakBarManager&gt;
</pre></div></p>
<p>Finally, in order to actually call the above methods, i.e., to display these overlays, we extend the cameraMethod with a new loop calling the "draw" method of all the scene nodes having the "overlay" flag:</p>
 <div class="fragment"><pre class="fragment">    &lt;sequence name=<span class="stringliteral">&quot;cameraMethod&quot;</span>&gt;
        &lt;<span class="keywordflow">foreach</span> var=<span class="stringliteral">&quot;o&quot;</span> flag=<span class="stringliteral">&quot;dynamic&quot;</span> parallel=<span class="stringliteral">&quot;true&quot;</span>&gt;
            &lt;callMethod name=<span class="stringliteral">&quot;$o.update&quot;</span>/&gt;
        &lt;/<span class="keywordflow">foreach</span>&gt;
        &lt;<span class="keywordflow">foreach</span> var=<span class="stringliteral">&quot;o&quot;</span> flag=<span class="stringliteral">&quot;object&quot;</span> culling=<span class="stringliteral">&quot;true&quot;</span>&gt;
            &lt;callMethod name=<span class="stringliteral">&quot;$o.draw&quot;</span>/&gt;
        &lt;/<span class="keywordflow">foreach</span>&gt;
        &lt;<span class="keywordflow">foreach</span> var=<span class="stringliteral">&quot;o&quot;</span> flag=<span class="stringliteral">&quot;overlay&quot;</span>&gt;
            &lt;callMethod name=<span class="stringliteral">&quot;$o.draw&quot;</span>/&gt;
        &lt;/<span class="keywordflow">foreach</span>&gt;
    &lt;/sequence&gt;
</pre></div></p>
<p>The second improvement in the user interface, compared to the "terrain1" example, is that we replace the basic mouse and keyboard handling methods introduced in the "helloworld" example with more "advanced" implementations, provided by the proland::BasicViewHandler class (which is a subclass of ork::EventHandler - in addition to the previous controls, it is also possible to move the camera with the arrow keys).</p>
<p>For this we remove the "mouseX", "mouseY" and "rotate" fields in "HelloWorld.cpp". Instead, we add a "view" field of type proland::BasicViewHandler, and a "ui" field of type ork::EventHandler. We initialize these fields in the construtor: we create the view handler manually, but we initialize the event handler by loading the "ui" resource with Ork (it is defined above to be a proland::TweakBarManager, a subclass of ork::EventHandler that manages the events related to the tweak bar). We finally link the two handlers with a call the "setNext" method: the effect of this is that the events not processed by the tweak bar will be forwarded to the view handler.</p>
<p>Most of the event handling work is now done by the "view" and "ui" event handlers, chained together, so that we can simplify the implementation of the "redisplay", "reshape", "idle", "mouseClick", "mouseMotion", "mouseWheel", "keyTyped" and "specialKey" methods to simply call the corresponding methods on "ui".</p>
<h2><a class="anchor" id="sec-terrain4">
Terrain4 example</a></h2>
 
<img src="terrain4.png"><br/>
 <!--  <div align="center">
<img src="terrain4.png" alt="terrain4.png"/>
</div>
  --> <p>This example is based on the "terrain3" example, with two modifications: first we replace the fractal terrain with a precomputed terrain, using a <a class="el" href="classproland_1_1ResidualProducer.html" title="A TileProducer to load elevation residuals from disk to CPU memory.">proland::ResidualProducer</a>, second we modify the shaders and the terrain mesh to dynamically flip the mesh diagonals, in order to reduce geometric aliasing.</p>
<h3><a class="anchor" id="sec-terrain4-res">
Residual producer</a></h3>
<p>In order to define the residual producer, we first define a tile cache "groundResiduals" on CPU:</p>
 <div class="fragment"><pre class="fragment">    &lt;tileCache name=<span class="stringliteral">&quot;groundResiduals&quot;</span> scheduler=<span class="stringliteral">&quot;defaultScheduler&quot;</span>&gt;
        &lt;cpuFloatTileStorage tileSize=<span class="stringliteral">&quot;197&quot;</span> channels=<span class="stringliteral">&quot;1&quot;</span> capacity=<span class="stringliteral">&quot;1024&quot;</span>/&gt;
    &lt;/tileCache&gt;
    &lt;residualProducer name=<span class="stringliteral">&quot;groundResiduals1&quot;</span> cache=<span class="stringliteral">&quot;groundResiduals&quot;</span> file=<span class="stringliteral">&quot;DEM.dat&quot;</span> delta=<span class="stringliteral">&quot;2&quot;</span>/&gt;
</pre></div></p>
<p>This tile cache can store up to 1024 tiles of size 197x197, with one float per pixel. We can then define a residual producer using this cache, which will load the residuals from the "DEM.dat" file. In this file the residuals are stored in tiles of size 197x197 (thus we <em>must</em> use this size for the tile cache), but only for tiles at level 3 or higher. For the first levels the tile sizes are 29=24+5 at level 0, 53=2*24+5 at level 1, and 101=4*24+5 at level 2. Since we want elevation tiles of size 101, we specify via the "delta" attribute that the "root 
level" should start in fact at level 2.</p>
<p><div class="fragment"><pre class="fragment">    &lt;tileCache name=<span class="stringliteral">&quot;groundElevations&quot;</span> scheduler=<span class="stringliteral">&quot;defaultScheduler&quot;</span>&gt;
        &lt;gpuTileStorage tileSize=<span class="stringliteral">&quot;101&quot;</span> nTiles=<span class="stringliteral">&quot;512&quot;</span>
            internalformat=<span class="stringliteral">&quot;RGB32F&quot;</span> format=<span class="stringliteral">&quot;RGB&quot;</span> type=<span class="stringliteral">&quot;FLOAT&quot;</span> min=<span class="stringliteral">&quot;LINEAR&quot;</span> mag=<span class="stringliteral">&quot;LINEAR&quot;</span>/&gt;
    &lt;/tileCache&gt;
    &lt;elevationProducer name=<span class="stringliteral">&quot;groundElevations1&quot;</span> cache=<span class="stringliteral">&quot;groundElevations&quot;</span>
        residuals=<span class="stringliteral">&quot;groundResiduals1&quot;</span> flip=<span class="stringliteral">&quot;true&quot;</span>/&gt;
</pre></div></p>
<p>Once this residual producer is defined we use it in the definition of the elevation producer. Here we removed the noise amplitudes that we used in the "terrain3" example, but it is possible to keep them to add fractal details to the precomputed terrain. And that's it, the above changes are the only ones necessary to replace a fractal terrain with a precomputed one (the "flip" attribute specifies that we will use dynamic terrain mesh diagonals flipping - see below).</p>
<h3><a class="anchor" id="sec-terrain4-flip">
Dynamic diagonal flipping</a></h3>
<p>Compared to a basic rendering, as in the "terrain3" example, three changes are needed to dynamically flip the terrain mesh diagonals to reduce geometric aliasing: </p>
<ul>
<li>
the mesh used to render each terrain quad must not use the "triangles" mode, but the "linesadjacency" mode. The goal is to have the four vertices of each mesh quad available in a geometry shader, in order to decide which diagonal to use for this quad, and then to emit the two corresponding triangles (see "quad.mesh"). </li>
<li>
the terrain shader must be extended with a geometry shader to transform the "lines_adjacency" topology into "triangle_strip" (see "terrainShader.glsl"). </li>
<li>
the upsample and add shader used to produce elevation tiles must be changed to correctly compute coarse elevations, taking into account that the coarse mesh quad diagonal orientation depends on the elevation of the four quad vertices (see "upsampleShader.glsl"). </li>
</ul>
<p>In "terrainShader.glsl" the main difference is the addition of the following geometry shader:</p>
 <div class="fragment"><pre class="fragment"><span class="preprocessor">#ifdef _GEOMETRY_</span>
<span class="preprocessor"></span><span class="preprocessor">#extension GL_EXT_geometry_shader4 : enable</span>
<span class="preprocessor"></span>
layout (lines_adjacency) in;
layout (triangle_strip,max_vertices=4) out;

in <span class="keywordtype">float</span> hIn[];
in vec2 uvIn[];
out vec2 uv;

<span class="keywordtype">void</span> emit(<span class="keywordtype">int</span> i) {
    gl_Position = gl_PositionIn[i];
    uv = uvIn[i];
    EmitVertex();
}

<span class="keywordtype">void</span> main() {
    <span class="keywordtype">int</span> a = hIn[3] + hIn[1] &gt;= hIn[0] + hIn[2] ? 0 : 5;
    emit(a % 4);
    emit((a + 1) % 4);
    emit((a + 3) % 4);
    emit((a + 2) % 4);
    EndPrimitive();
}

<span class="preprocessor">#endif</span>
</pre></div></p>
<p>Assuming that the four input vertices are the vertices of a mesh quad, in counter clockwise order and starting from the bottomleft, this code checks if the northwest-southeast diagonal would give a convex quad or not. If then outputs two triangles using this diagonal if it is the case (a=0), or the other one if it is not (a=5);</p>
<p>In "upsampleShader.glsl" the only difference, compared to the "terrain3" example, is the computation of the coarse elevation. Instead of simply using the average of the elevations of the vertices of the northwest-southeast diagonal (zc1+zc3)/2, we must now use either this average, or the average for the other diagonal, depending on which diagonal will be used for the coarse quad (using the same criterion as above):</p>
 <div class="fragment"><pre class="fragment">        <span class="keywordflow">if</span> (tileWSDF.w &gt; 0.0 &amp;&amp; all(equal(mod(ij, 2.0 * tileWSDF.z), vec2(tileWSDF.z)))) {
            <span class="keywordtype">float</span> zc0 = textureLod(coarseLevelSampler, vec3(uvc.zy * coarseLevelOSL.z, 0.0) + coarseLevelOSL.xyw, 0.0).z;
            <span class="keywordtype">float</span> zc2 = textureLod(coarseLevelSampler, vec3(uvc.xw * coarseLevelOSL.z, 0.0) + coarseLevelOSL.xyw, 0.0).z;
            zc = (zc3 + zc1 &gt;= zc0 + zc2 ? zc1 + zc3 : zc0 + zc2) * 0.5;
        } <span class="keywordflow">else</span> {
            zc = (zc1 + zc3) * 0.5;
        }
</pre></div></p>
<p>The example terrain has a regular, circular ridge designed to clearly show the geometric aliasing problem (for real terrains this problem is much less visible because the ridges are not so regular in general). You can see below that the dynamic diagonal flipping (left) reduces the artifacts, compared to fixed diagonals (right), but does not fully eliminate them.</p>
 
<center>
<img src="terrain4-a.png"> <img src="terrain4-b.png"><br/>
</center>
 <!--  <div align="center">
<img src="terrain4-a.png" alt="terrain4-a.png"/>
</div>
 <div align="center">
<img src="terrain4-b.png" alt="terrain4-b.png"/>
</div>
  --> <dl class="note"><dt><b>Note:</b></dt><dd>you can replace the "int a = ..." line above with "a = 0;", while the program is running, to immediately see the effect of this algorithm on the terrain.</dd></dl>
<h2><a class="anchor" id="sec-terrain5">
Terrain5 example</a></h2>
 
<img src="terrain5.png"><br/>
 <!--  <div align="center">
<img src="terrain5.png" alt="terrain5.png"/>
</div>
  --> <p>This example is based on the "terrain3" example, with three modifications: possibility to change the Sun position interactively, addition of a new "terrain" with a specific mesh to render "clouds", and use of the "tileMap" option in a tile sampler (see sec-tilemap) to render the shadows of clouds on the terrain.</p>
<h3><a class="anchor" id="sec-terrain5-sun">
Dynamic Sun</a></h3>
<p>In order to dynamically move the Sun, we first add a node for the Sun in the scene graph:</p>
 <div class="fragment"><pre class="fragment">        &lt;node name=<span class="stringliteral">&quot;sun&quot;</span> flags=<span class="stringliteral">&quot;light&quot;</span>&gt;
            &lt;translate x=<span class="stringliteral">&quot;0&quot;</span> y=<span class="stringliteral">&quot;0&quot;</span> z=<span class="stringliteral">&quot;1&quot;</span>/&gt;
            &lt;method <span class="keywordtype">id</span>=<span class="stringliteral">&quot;draw&quot;</span> value=<span class="stringliteral">&quot;sunMethod&quot;</span>/&gt;
        &lt;/node&gt;
</pre></div></p>
<p>We set its "position", which will in fact be interpreted as a direction, to the zenith, i.e., (0,0,1). We also associate to this node, having the "light" flag, a "draw" method. This method is defined as follows:</p>
 <div class="fragment"><pre class="fragment">    &lt;sequence name=<span class="stringliteral">&quot;sunMethod&quot;</span>&gt;
        &lt;setTransforms module=<span class="stringliteral">&quot;globalsShader&quot;</span> worldPos=<span class="stringliteral">&quot;worldSunDir&quot;</span>/&gt;
    &lt;/sequence&gt;
</pre></div></p>
<p>In other words the "draw" method for the Sun simply sets the current position of this node in the "worldSunDir" uniform of the "globalsShader" shader. This shader is very simple, its goal is to hold the global variables needed by the other shaders (here only the Sun direction):</p>
 <div class="fragment"><pre class="fragment">uniform globals {
    vec3 worldSunDir;
};

vec3 getWorldSunDir() {
    <span class="keywordflow">return</span> worldSunDir;
}
</pre></div></p>
<p>Now, in order to be able to access these global variables in the other shaders, we need to link them together. For instance, we add a reference to the "globalsShader" in the "drawTerrainMethod" as follows:</p>
 <div class="fragment"><pre class="fragment">    &lt;sequence name=<span class="stringliteral">&quot;drawTerrainMethod&quot;</span>&gt;
        &lt;setProgram&gt;
            &lt;module name=<span class="stringliteral">&quot;globalsShader&quot;</span>/&gt;
            &lt;module name=<span class="stringliteral">&quot;this.material&quot;</span>/&gt;
        &lt;/setProgram&gt;
        &lt;drawTerrain name=<span class="stringliteral">&quot;this.terrain&quot;</span> mesh=<span class="stringliteral">&quot;this.grid&quot;</span> culling=<span class="stringliteral">&quot;true&quot;</span>/&gt;
    &lt;/sequence&gt;
</pre></div></p>
<p>Finally, we need to call the "draw" method for the Sun node before we render the objects in the scene. For this we insert a new loop over the nodes having the "light" flag in the camera method:</p>
 <div class="fragment"><pre class="fragment">    &lt;sequence name=<span class="stringliteral">&quot;cameraMethod&quot;</span>&gt;
        &lt;<span class="keywordflow">foreach</span> var=<span class="stringliteral">&quot;o&quot;</span> flag=<span class="stringliteral">&quot;dynamic&quot;</span> parallel=<span class="stringliteral">&quot;true&quot;</span>&gt;
            &lt;callMethod name=<span class="stringliteral">&quot;$o.update&quot;</span>/&gt;
        &lt;/<span class="keywordflow">foreach</span>&gt;
        &lt;<span class="keywordflow">foreach</span> var=<span class="stringliteral">&quot;l&quot;</span> flag=<span class="stringliteral">&quot;light&quot;</span>&gt;
            &lt;callMethod name=<span class="stringliteral">&quot;$l.draw&quot;</span>/&gt;
        &lt;/<span class="keywordflow">foreach</span>&gt;
        &lt;<span class="keywordflow">foreach</span> var=<span class="stringliteral">&quot;o&quot;</span> flag=<span class="stringliteral">&quot;object&quot;</span> culling=<span class="stringliteral">&quot;true&quot;</span>&gt;
            &lt;callMethod name=<span class="stringliteral">&quot;$o.draw&quot;</span>/&gt;
        &lt;/<span class="keywordflow">foreach</span>&gt;
        &lt;<span class="keywordflow">foreach</span> var=<span class="stringliteral">&quot;o&quot;</span> flag=<span class="stringliteral">&quot;overlay&quot;</span>&gt;
            &lt;callMethod name=<span class="stringliteral">&quot;$o.draw&quot;</span>/&gt;
        &lt;/<span class="keywordflow">foreach</span>&gt;
    &lt;/sequence&gt;
</pre></div></p>
<dl class="note"><dt><b>Note:</b></dt><dd>the proland::BasicViewHandler allows the Sun direction to be changed interactively by dragging the mouse with the right button pressed. For this it expects the scene graph to have a single node having the "light" flag.</dd></dl>
<h3><a class="anchor" id="sec-terrain5-clouds">
Clouds</a></h3>
<p>In order to render clouds we use a "terrain", placed above the real terrain, rendered with a two-sided mesh to draw both the top and bottom of clouds, and with some fragments discarded to make holes between clouds.</p>
<p>So we first define an elevation producer and a normal producer for the clouds "terrain", like we would do for any terrain (the only difference is the <code>tileMap="true"</code> option in the elevation tile cache, but this is needed only to draw the clouds shadows - see below):</p>
 <div class="fragment"><pre class="fragment">    &lt;tileCache name=<span class="stringliteral">&quot;cloudElevations&quot;</span> scheduler=<span class="stringliteral">&quot;defaultScheduler&quot;</span>&gt;
        &lt;gpuTileStorage tileSize=<span class="stringliteral">&quot;101&quot;</span> nTiles=<span class="stringliteral">&quot;512&quot;</span> tileMap=<span class="stringliteral">&quot;true&quot;</span>
            internalformat=<span class="stringliteral">&quot;RGB32F&quot;</span> format=<span class="stringliteral">&quot;RGB&quot;</span> type=<span class="stringliteral">&quot;FLOAT&quot;</span> min=<span class="stringliteral">&quot;LINEAR&quot;</span> mag=<span class="stringliteral">&quot;LINEAR&quot;</span>/&gt;
    &lt;/tileCache&gt;
    &lt;elevationProducer name=<span class="stringliteral">&quot;cloudElevations1&quot;</span> cache=<span class="stringliteral">&quot;cloudElevations&quot;</span>
        noise=<span class="stringliteral">&quot;-100,-100,-100,-8,5,2.5,1.5,1,0.5,0.25,0.1,0.05&quot;</span>/&gt;

    &lt;tileCache name=<span class="stringliteral">&quot;cloudNormals&quot;</span> scheduler=<span class="stringliteral">&quot;defaultScheduler&quot;</span>&gt;
        &lt;gpuTileStorage tileSize=<span class="stringliteral">&quot;97&quot;</span> nTiles=<span class="stringliteral">&quot;512&quot;</span>
            internalformat=<span class="stringliteral">&quot;RG8&quot;</span> format=<span class="stringliteral">&quot;RG&quot;</span> type=<span class="stringliteral">&quot;FLOAT&quot;</span> min=<span class="stringliteral">&quot;LINEAR&quot;</span> mag=<span class="stringliteral">&quot;LINEAR&quot;</span>/&gt;
    &lt;/tileCache&gt;
    &lt;normalProducer name=<span class="stringliteral">&quot;cloudNormals1&quot;</span> cache=<span class="stringliteral">&quot;cloudNormals&quot;</span> elevations=<span class="stringliteral">&quot;cloudElevations1&quot;</span>/&gt;
</pre></div></p>
<p>We also define a terrain for the clouds:</p>
 <div class="fragment"><pre class="fragment">    &lt;terrainNode name=<span class="stringliteral">&quot;clouds&quot;</span> size=<span class="stringliteral">&quot;50000&quot;</span> zmin=<span class="stringliteral">&quot;0&quot;</span> zmax=<span class="stringliteral">&quot;5000&quot;</span> splitFactor=<span class="stringliteral">&quot;2&quot;</span> maxLevel=<span class="stringliteral">&quot;6&quot;</span>/&gt;
</pre></div></p>
<p>Since we want to draw the clouds from below, and since we will also want to draw their shadows on the ground (see below), which can come from clouds outside the view frustum, we do not want here to perform frustum culling while rendering the clouds "terrain". For this we define a new version of the "drawTerrainMethod", with frustum culling disabled, and called "drawCloudMethod" (note that we also include "globalsShader", to be able to access the Sun direction in the cloud shader):</p>
 <div class="fragment"><pre class="fragment">    &lt;sequence name=<span class="stringliteral">&quot;drawCloudMethod&quot;</span>&gt;
        &lt;setProgram&gt;
            &lt;module name=<span class="stringliteral">&quot;globalsShader&quot;</span>/&gt;
            &lt;module name=<span class="stringliteral">&quot;this.material&quot;</span>/&gt;
        &lt;/setProgram&gt;
        &lt;drawTerrain name=<span class="stringliteral">&quot;this.terrain&quot;</span> mesh=<span class="stringliteral">&quot;this.grid&quot;</span> culling=<span class="stringliteral">&quot;false&quot;</span>/&gt;
    &lt;/sequence&gt;
</pre></div></p>
<p>Finally we simply need to add a scene node for the clouds in the scene graph, using the above resources:</p>
 <div class="fragment"><pre class="fragment">        &lt;node name=<span class="stringliteral">&quot;cloudsNode&quot;</span> flags=<span class="stringliteral">&quot;object,dynamic&quot;</span>&gt;
            &lt;translate z=<span class="stringliteral">&quot;1000&quot;</span>/&gt;
            &lt;bounds xmin=<span class="stringliteral">&quot;-50000&quot;</span> xmax=<span class="stringliteral">&quot;50000&quot;</span> ymin=<span class="stringliteral">&quot;-50000&quot;</span> ymax=<span class="stringliteral">&quot;50000&quot;</span> zmin=<span class="stringliteral">&quot;0&quot;</span> zmax=<span class="stringliteral">&quot;5000&quot;</span>/&gt;
            &lt;field <span class="keywordtype">id</span>=<span class="stringliteral">&quot;terrain&quot;</span> value=<span class="stringliteral">&quot;clouds&quot;</span>/&gt;
            &lt;tileSamplerZ <span class="keywordtype">id</span>=<span class="stringliteral">&quot;elevation&quot;</span> sampler=<span class="stringliteral">&quot;elevationSampler&quot;</span> producer=<span class="stringliteral">&quot;cloudElevations1&quot;</span> storeInvisible=<span class="stringliteral">&quot;true&quot;</span>/&gt;
            &lt;tileSampler <span class="keywordtype">id</span>=<span class="stringliteral">&quot;fnormal&quot;</span> sampler=<span class="stringliteral">&quot;fragmentNormalSampler&quot;</span> producer=<span class="stringliteral">&quot;cloudNormals1&quot;</span> storeParent=<span class="stringliteral">&quot;false&quot;</span> storeInvisible=<span class="stringliteral">&quot;true&quot;</span>/&gt;
            &lt;mesh <span class="keywordtype">id</span>=<span class="stringliteral">&quot;grid&quot;</span> value=<span class="stringliteral">&quot;cloud.mesh&quot;</span>/&gt;
            &lt;method <span class="keywordtype">id</span>=<span class="stringliteral">&quot;update&quot;</span> value=<span class="stringliteral">&quot;updateTerrainMethod&quot;</span>/&gt;
            &lt;method <span class="keywordtype">id</span>=<span class="stringliteral">&quot;draw&quot;</span> value=<span class="stringliteral">&quot;drawCloudMethod&quot;</span>/&gt;
            &lt;module <span class="keywordtype">id</span>=<span class="stringliteral">&quot;material&quot;</span> value=<span class="stringliteral">&quot;cloudShader&quot;</span>/&gt;
        &lt;/node&gt;
</pre></div></p>
<p>Note that we translate the clouds "terrain" in z direction, to place it above the real terrain. We also set the "storeInvisible" option to true, to keep all the cloud tiles in cache, even those that are outside the view frustum. The "cloud.mesh" is also different from the "quad.mesh" used for the terrain: it contains two parallel 24x24 grids, one at z=0, the other at z=1. The first grid is used to render the bottom of clouds, while the second is used for the clouds top. This is done by the "cloudShader.glsl" shader, which is very similar to the "terrainShader.glsl" of the "terrain3" example (the main differences are the "discard" in the fragment shader, to make holes between clouds, and the use of the "getWorldSunDir()" external function to replace the fixed Sun direction previously used).</p>
<h3><a class="anchor" id="sec-terrain5-cloudshadow">
Clouds shadows</a></h3>
<p>In order to render the shadows of clouds on the ground, the idea is to compute the intersection of the light ray between the current point on the terrain, and the bottom plane of clouds. Then, if there is a cloud at this intersection point, the point on the terrain is in shadow (this is only an approximation, because we neglect the 3D shape of the top part of clouds). In order to implement this idea we need access to the cloud tiles from the terrain shader. However, when rendering a given terrain tile, we may need to access a different tile in the cloud tile cache, when the Sun is not at zenith. This is what tile maps are done for. The first step to use them is to add a tile sampler for the cloud tile producer in the terrain node:</p>
 <div class="fragment"><pre class="fragment">        &lt;node name=<span class="stringliteral">&quot;terrainNode&quot;</span> flags=<span class="stringliteral">&quot;object,dynamic&quot;</span>&gt;
            &lt;bounds xmin=<span class="stringliteral">&quot;-50000&quot;</span> xmax=<span class="stringliteral">&quot;50000&quot;</span> ymin=<span class="stringliteral">&quot;-50000&quot;</span> ymax=<span class="stringliteral">&quot;50000&quot;</span> zmin=<span class="stringliteral">&quot;0&quot;</span> zmax=<span class="stringliteral">&quot;5000&quot;</span>/&gt;
            &lt;field <span class="keywordtype">id</span>=<span class="stringliteral">&quot;terrain&quot;</span> value=<span class="stringliteral">&quot;terrain&quot;</span>/&gt;
            &lt;tileSamplerZ <span class="keywordtype">id</span>=<span class="stringliteral">&quot;elevation&quot;</span> sampler=<span class="stringliteral">&quot;elevationSampler&quot;</span> producer=<span class="stringliteral">&quot;groundElevations1&quot;</span> storeInvisible=<span class="stringliteral">&quot;false&quot;</span>/&gt;
            &lt;tileSampler <span class="keywordtype">id</span>=<span class="stringliteral">&quot;fnormal&quot;</span> sampler=<span class="stringliteral">&quot;fragmentNormalSampler&quot;</span> producer=<span class="stringliteral">&quot;groundNormals1&quot;</span> storeParent=<span class="stringliteral">&quot;false&quot;</span> storeInvisible=<span class="stringliteral">&quot;false&quot;</span>/&gt;
            &lt;tileSampler <span class="keywordtype">id</span>=<span class="stringliteral">&quot;clouds&quot;</span> sampler=<span class="stringliteral">&quot;cloudsSampler&quot;</span> producer=<span class="stringliteral">&quot;cloudElevations1&quot;</span> terrains=<span class="stringliteral">&quot;clouds,&quot;</span>/&gt;
            &lt;mesh <span class="keywordtype">id</span>=<span class="stringliteral">&quot;grid&quot;</span> value=<span class="stringliteral">&quot;quad.mesh&quot;</span>/&gt;
            &lt;method <span class="keywordtype">id</span>=<span class="stringliteral">&quot;update&quot;</span> value=<span class="stringliteral">&quot;updateTerrainMethod&quot;</span>/&gt;
            &lt;method <span class="keywordtype">id</span>=<span class="stringliteral">&quot;draw&quot;</span> value=<span class="stringliteral">&quot;drawTerrainMethod&quot;</span>/&gt;
            &lt;module <span class="keywordtype">id</span>=<span class="stringliteral">&quot;material&quot;</span> value=<span class="stringliteral">&quot;terrainShader&quot;</span>/&gt;
        &lt;/node&gt;
</pre></div></p>
<p>Unlike the other tile samplers, the "clouds" sampler here has a "terrains" attribute: this means that this sampler will be used to access the tile maps of the specified terrains (here "clouds"). The effect of this new tile sampler is that the tile maps for the specified terrains will be updated at each frame, and that the uniforms needed to access these maps will be also updated at each frame (here in the "cloudsSampler" GLSL uniforms).</p>
<p>The second step is to use these uniforms, in the terrain shader, to access the tile map and to perform the shadows computation. These uniforms and the "textureQuadtree" function that uses them can be found at the begining of the "terrainShader.glsl" file (they implement the algorithm described in sec-tilemap). This function is then used in the fragment shader in a straightforward way (we simply compute the intersection point "cp" and lookup the "cloudsSampler" map at this point to find whether the current point "p" is in shadow or not).</p>
<h2><a class="anchor" id="sec-preprocess">
Preprocess example</a></h2>
 
<img src="preprocess.png"><br/>
 <!--  <div align="center">
<img src="preprocess.png" alt="preprocess.png"/>
</div>
  --> <p>This example mixes several elements from the "terrain2", "terrain3" and "edit2" examples, and illustrates how you can generate the files needed by <a class="el" href="classproland_1_1ResidualProducer.html" title="A TileProducer to load elevation residuals from disk to CPU memory.">proland::ResidualProducer</a> and <a class="el" href="classproland_1_1OrthoCPUProducer.html" title="A TileProducer to load any kind of texture tile from disk to CPU memory.">proland::OrthoCPUProducer</a>. More precisely, this example reuses the "HelloWorld.cpp" class and the user interface resources of the "helloworld.xml" file of the "edit2" example. It also reuses the "upsampleShader", "normalShader" and "terrainShader" from the "terrain2" example (as well as the general structure of its "helloworld.xml" file). Finally it reuses the "upsampleOrthoShader" from the "terrain3" example.</p>
<p>The main changes are related to the preprocessing of the "srtm" and "bluemarble" images, in "HelloWorld.cpp". The elevation image "srtm" is preprocessed with the following call, in the "main" function:</p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__preprocess.html#ga7032f8c7bc37442f64472b0e1350e30b" title="Preprocess a spherical elevation map into six files that can be used with six proland::ResidualProdu...">preprocessSphericalDem</a>(<span class="keyword">new</span> MyMap(<span class="stringliteral">&quot;srtm.png&quot;</span>, 10000.0 / 255.0), 
    24, 192, 2, <span class="stringliteral">&quot;data/dem&quot;</span>, <span class="stringliteral">&quot;tmpDem&quot;</span>, 1.0);
</pre></div><p>This indicates that the "srtm.png" file must be interpreted as a spherial map, with elevations in meters encoded into bytes by using the scale 10000.0 / 255.0 (i.e. a 255.0 value means 10000.0 meters) and that it must be preprocessed into the "data/dem" output folder, using the "tmpDem" folder for temporary files, into tiles of size between 24 (for the root, 29 with borders) and 192 (197 with borders), up to quadtree level 2 (starting from the tiles of size 192, i.e., level 5 from the root). The last argument specifies that residuals must be divided by 1.0 before beeing stored (into short values).</p>
<p>The terrain texture is preprocessed in a similar way:</p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__preprocess.html#ga2557d06af7d38635493fde4d40e239f3" title="Preprocess a spherical map into files that can be used with a proland::OrthoCPUProducer...">preprocessSphericalOrtho</a>(<span class="keyword">new</span> MyMap(<span class="stringliteral">&quot;bluemarble.png&quot;</span>, 1.0), 
    192, 4, 2, <span class="stringliteral">&quot;data/rgb&quot;</span>, <span class="stringliteral">&quot;tmpOrtho&quot;</span>);
</pre></div><p>This indicates that the "bluemarble.png" file must be interpreted as a spherial map, with colors encoded into bytes with a scale 1.0 (i.e. a 255.0 value means 255) and that it must be preprocessed into the "data/rgb" output folder, using the "tmpOrtho" folder for temporary files, into tiles of size 192 (196 with borders), with 4 components per pixel, up to quadtree level 2.</p>
<p>The "MyMap" class used above is also defined in "HelloWorld.cpp". It is a subclass of the <a class="el" href="classproland_1_1InputMap.html" title="An abstract raster data map.">proland::InputMap</a> class, which can not be instantiated because its getValue method is purely abstract. This method must simply return the value of a pixel, which can be implemented very easily for small maps (i.e. that fit in main memory):</p>
<dl class="note"><dt><b>Note:</b></dt><dd>the preprocessing can be interrupted at any time. Computations will restart where they were stopped when you relaunch the preprocessing. For very large maps, memory fragmentation sometime leads to "out of memory" errors and thus the preprocessing stops. Then you can simply relaunch it to continue the computations (without recomputing the already generated files). Once the precomputations are done, you can safely delete the temporay folders.</dd></dl>
 <div class="fragment"><pre class="fragment"><span class="keyword">class </span>MyMap : <span class="keyword">public</span> InputMap
{
<span class="keyword">public</span>:
    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *bitmap;

    <span class="keywordtype">float</span> scale;

    MyMap(<span class="keyword">const</span> <span class="keywordtype">string</span> &amp;file, <span class="keywordtype">float</span> scale) : InputMap(1350, 675, 4, 225), scale(scale)
    {
        ifstream fs(file.c_str(), ios::binary);
        fs.seekg(0, ios::end);
        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size = fs.tellg();
        <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *data = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>[size];
        fs.seekg(0);
        fs.read((<span class="keywordtype">char</span>*) data, size);
        fs.close();
        <span class="keywordtype">int</span> w, h, channels;
        bitmap = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) stbi_load_from_memory(data, size, &amp;w, &amp;h, &amp;channels, 0);
        <span class="keyword">delete</span>[] data;
    }

    vec4f getValue(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y)
    {
        vec4f c;
        c.x = bitmap[(x + y * width) * 3] * scale;
        c.y = bitmap[(x + y * width) * 3 + 1] * scale;
        c.z = bitmap[(x + y * width) * 3 + 2] * scale;
        c.w = 0.0;
        <span class="keywordflow">return</span> c;
    }
};
</pre></div></p>
<p>Here the constructor simply loads an image into an array, and the getValue method reads this array to return its result. For much larger maps it is advised to override the getValues method, which must return a whole region of the map at once (the size of this region is specified in the last argument of the InputMap constructor - here 225. It must be a divisor of the width and height of the input map).</p>
<h2><a class="anchor" id="sec-exercise1">
Exercise 1</a></h2>
 
<img src="exercise1a.png"> <img src="exercise1b.png"> <img src="exercise1c.png"><br/>
 <!--  <div align="center">
<img src="exercise1a.png" alt="exercise1a.png"/>
</div>
 <div align="center">
<img src="exercise1b.png" alt="exercise1b.png"/>
</div>
 <div align="center">
<img src="exercise1c.png" alt="exercise1c.png"/>
</div>
  --> <p>The goal of this exercise is to extend the "terrain3" example with the sky and the ocean of the "ocean1" example. For this: </p>
<ul>
<li>
Create a new folder "exercise1": copy the files from the "terrain3" example in this folder, as well as the "oceanShader.glsl" from the "ocean1" example. Finally copy the "HelloWorld.cpp" file from the "ocean1" example into your new directory (replace the one from the "terrain3" example). </li>
<li>
Copy the necessary resources from the "ocean1/helloworld.xml" file into "exercise1/helloworld.xml": replace the "cameraMethod" resource, copy all the resources from "drawOceanMethod" to "sunglare", copy the "sun", "ocean" and "sky" scene nodes into the "scene" node (put the "sky" node at the end). Finally replace the tweakScene and tweakBarManager resources with all the resources from "viewHandler" to "window" (from the "ocean1/helloword.xml" file). </li>
<li>
Adapt the resource attributes for a flat terrain (the "ocean1" example uses a spherical terrain, but we want a flat terrain as in the "terrain3" example): remove the "radius" attribute in the "window" resource, set the "radius" attribute to 0 in the draw ocean method, set "z=6360000" in the "origin" uniform of the sky shader, and finally set a better initial Sun position in the "translate" element of the "sun" scene node (use 0,0,1). </li>
</ul>
<p>The result should look like the left image above. This is not very realistic, because the ocean is shaded with atmospheric effects, while the terrain is not. To solve this problem: </p>
<ul>
<li>
Add the "globalsShader" and "atmosphereShader" modules in the "setProgram" part of the drawTerrainMethod (in order to be able to access the corresponding uniforms and functions in the terrain shader). </li>
<li>
Modify the "terrainShader.glsl" file: transform "p" in the vertex shader into a variable sent to the fragment shader, add a include "atmosphereShader.glhl" in the fragment shader, and copy from the "oceanShader.glsl" the getWorldCameraPos(), getWorldSunDir() and hdr() function prototypes, as well as the whole sunRadianceAndSkyIrradiance function (you will need them in the "main" function). </li>
<li>
Copy from the "oceanShader.glsl" the WSD and WCP variables, the call to the sunRadianceAndSkyIrradiance function, and the code from "inscatter = ..." to "data.rgb = hdr(finalColor);" </li>
<li>
Rename the variables to connect this new code to the existing one correctly: replace earthP with p, N with n, oceanSunDir with WSD, earthCamera with WCP, surfaceColor with data.rgb, and finalColor with data.rgb. </li>
</ul>
<p>The result should look like the middle image above. Note that this is still not a "physically correct" lighting, because the terrin color, before applying the atmospheric effects, is still computed with the following ad-hoc model (which also uses a fixed Sun direction, yielding a non black terrain at night!): </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">float</span> light = dot(n, normalize(vec3(1.0)));
data.rgb *= 0.5 + 0.75 * light;
</pre></div><p> To improve this you need to replace these lines with the following ones (the 0.1 factor is used to convert to data.rgb ad-hoc value to a physical albedo, which is typically in the range 0.1 - 0.2 for vegetation): </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">float</span> cosTheta = dot(n, WSD);
vec3 lightColor = (sunL * max(cosTheta, 0.0) + skyE) / 3.14159265;
data.rgb = 0.1 * data.rgb * lightColor;
</pre></div><p>The result should now look like the right image above. Note that a transition is visible when the camera goes below 20000 above the ground, when the ocean suddenly appears. The solution to this problem is to shade the ocean parts, in "terrainShader.glsl", as done in the "oceanShader.glsl" (for this you need to copy the code computing Lsun, Lsky, and Lsea and to rename the variables appropriately. You will also need to replace sigmaSq with sigmaSqTotal. This code uses two uniforms that will need to be accessible in "terrainShader.glsl", namely "sigmaSqTotal" and "seaColor". To solve this problem you will need to move them into "globalsShader").</p>
<h2><a class="anchor" id="sec-exercise2">
Exercise 2</a></h2>
 
<img src="exercise2.png">
 <!--  <div align="center">
<img src="exercise2.png" alt="exercise2.png"/>
</div>
  --> <p>The goal of this exercise is to extend the "trees1" example in order to interactively edit the tree density map. For this: </p>
<ul>
<li>
Create a new folder "exercise2": copy the files from the "trees1" example in this folder, as well as the "initOrthoShader.glsl", "brushOrthoShader.glsl", "composeOrthoShader.glsl" and "upsampleOrthoShader.glsl" files from the "edit2" example. Copy also the corresponding resources from the "edit2/helloworld.xml" file into the "exercise2/helloworld.xml" file. </li>
</ul>
<p>As a first step, replace the LCC producer with an editOrthoProducer, ignoring the LCC producer layers for the moment (recall that they ensure that no trees can be generated on oceans or on cliffs). For this: </p>
<ul>
<li>
remove or comment the "groundLccGpu" and "groundLccGpu1" resources in the "hellworld.xml" file. </li>
<li>
copy the editOrthoCpuProducer and the editOrthoProducer resources from the "edit2" example into this file (with the corresponding tile caches). </li>
<li>
rename the copied resources to "groundLccCpu", "groundLccCpu1", "groundLccGpu" and "groundLccGpu1", set the tile sizes to 100, the number of channels to 1, and the texture formats to R8 and RED. </li>
</ul>
<p>At this stage the example should be working, but without any trees and without any edition capabilities. This is normal since we used an editOrthoCpuProducer without any precomputed texture, which therefore uses an empty one. Also we haven't added yet the user interface components to enable texture editing. To solve this: </p>
<ul>
<li>
copy the "editOrtho" resource from the "edit2" example, as well as the "ortho" editor element in the tweakBarManager resource. </li>
<li>
copy the "pencil" and "pencilColor" uniforms from the "terrainShader.glsl" file in the "edit2" example, into the "exercise2/terrainShader.glsl". Copy also the "data += pencilColor;" line and the surrounding if statement. Finally convert the "p" variable in the vertex shader to a variable sent to the fragment shader. </li>
</ul>
<p>The example should now be working again, and this time you should be able to edit the LCC map interactively. Trees should then appear where you painted on the terrain. There is however a problem, namely that you can plant trees in oceans and cliffs. This is due to the fact that we removed, for the moment, the "slopeFilter" and "elevationFilter" layers from the LCC producer. The problem is that we cannot add them back directly in our new editOrthoProducer, because this kind of producer cannot have layers. The solution is to use two producers: </p>
<ul>
<li>
rename the "groundLccGpu1" producer to "backgroundLccGpu1". </li>
<li>
add a new orthoGpuProducer named "groundLccGpu1", and defined as follows: <div class="fragment"><pre class="fragment">&lt;orthoGpuProducer name=<span class="stringliteral">&quot;groundLccGpu1&quot;</span> cache=<span class="stringliteral">&quot;groundLccGpu&quot;</span> maxLevel=<span class="stringliteral">&quot;7&quot;</span>&gt;
    &lt;textureLayer name=<span class="stringliteral">&quot;background&quot;</span> producer=<span class="stringliteral">&quot;backgroundLccGpu1&quot;</span> 
        tileSamplerName=<span class="stringliteral">&quot;sourceSampler&quot;</span> renderProg=<span class="stringliteral">&quot;copyShader;&quot;</span> storeTiles=<span class="stringliteral">&quot;true&quot;</span>
        equation=<span class="stringliteral">&quot;ADD&quot;</span> destinationFunction=<span class="stringliteral">&quot;ZERO&quot;</span> sourceFunction=<span class="stringliteral">&quot;ONE&quot;</span>
        equationAlpha=<span class="stringliteral">&quot;ADD&quot;</span> destinationFunctionAlpha=<span class="stringliteral">&quot;ZERO&quot;</span> sourceFunctionAlpha=<span class="stringliteral">&quot;ONE&quot;</span>/&gt;
    &lt;textureLayer name=<span class="stringliteral">&quot;slopeFilter1&quot;</span> producer=<span class="stringliteral">&quot;groundNormals1&quot;</span>
        renderProg=<span class="stringliteral">&quot;slopeFilter;&quot;</span> tileSamplerName=<span class="stringliteral">&quot;fragmentNormalSampler&quot;</span>/&gt;
    &lt;textureLayer name=<span class="stringliteral">&quot;elevationFilter1&quot;</span> producer=<span class="stringliteral">&quot;groundElevations1&quot;</span>
        renderProg=<span class="stringliteral">&quot;elevationFilter;&quot;</span> tileSamplerName=<span class="stringliteral">&quot;elevationSampler&quot;</span>/&gt;
&lt;/orthoGpuProducer&gt;
</pre></div> This producer does not use any associated CPU producer, and so starts with empty tiles. The first layer copies the tiles produced by our "backgroundLccGpu1" producer, by using the "copyShader" shader, in which the "backgroundLccGpu1" tiles are accessible via the "sourceSampler" uniform (the source code for this shader is given below). The two other layers are the ones initially used in the LCC producer of the "trees1" example. </li>
</ul>
<p>The "copyShader.glsl" file must be defined as follows:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#ifdef _VERTEX_</span>
<span class="preprocessor"></span>layout(location=0) in vec4 vertex;
out vec2 uv;

<span class="keywordtype">void</span> main() {
    gl_Position = vec4(vertex.xy, 0.0, 1.0);
    uv = vertex.xy * 0.5 + vec2(0.5);
}
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="preprocessor">#ifdef _FRAGMENT_</span>
<span class="preprocessor"></span><span class="preprocessor">#include &quot;textureTile.glsl&quot;</span>

uniform samplerTile sourceSampler;

in vec2 uv;
layout(location=0) out vec4 data;

<span class="keywordtype">void</span> main() {
    data = textureTile(sourceSampler, uv);
}
<span class="preprocessor">#endif</span>
</pre></div><p>The example should now be working as expected, i.e., even if you paint on oceans or cliffs, the layers will set the density back to 0 in these areas, and thus no trees will appear in these areas.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>the "storeTiles=true" attribute in the background layer specifies that "backgroundLccGpu1" tiles must be locked in their cache as long as the corresponding "groundLccGpu1" tiles are locked (by default this is not the case: the "backgroundLccGpu1" are locked only during the <em>production</em> of the corresponding "groundLccGpu1" tiles, and can then be evicted from the cache at any time). This is needed to ensure proper edition of these tiles, because the editOrthoProducer requires the tiles corresponding to the visible terrain quads to be present in cache during edition.</dd></dl>
<h2><a class="anchor" id="sec-exercise3">
Exercise 3</a></h2>
 
<img src="exercise3.png">
 <!--  <div align="center">
<img src="exercise3.png" alt="exercise3.png"/>
</div>
  --> <p>The goal of this exercise is to implement a user defined task, to draw the bounding boxes of the terrain quads (see the above image). Starting from the "terrain3" example, what we want to do is to extend the "drawTerrainMethod" resource with a new "drawTerrainBox" task, as follows:</p>
<div class="fragment"><pre class="fragment">&lt;sequence name=<span class="stringliteral">&quot;drawTerrainMethod&quot;</span>&gt;
    &lt;setProgram&gt;
        &lt;module name=<span class="stringliteral">&quot;this.material&quot;</span>/&gt;
    &lt;/setProgram&gt;
    &lt;drawTerrain name=<span class="stringliteral">&quot;this.terrain&quot;</span> mesh=<span class="stringliteral">&quot;this.grid&quot;</span> culling=<span class="stringliteral">&quot;true&quot;</span>/&gt;
    &lt;setProgram&gt;
        &lt;module name=<span class="stringliteral">&quot;boxShader&quot;</span>/&gt;
    &lt;/setProgram&gt;
    &lt;drawTerrainBox name=<span class="stringliteral">&quot;this.terrain&quot;</span> mesh=<span class="stringliteral">&quot;box&quot;</span> culling=<span class="stringliteral">&quot;false&quot;</span>/&gt;
&lt;/sequence&gt;
</pre></div><p>We want this task to use the current program (here the "boxShader" shader set just before calling the task) to draw the mesh specified in the "mesh" attribute for each terrain quad of the terrain specified in the "name" attribute.</p>
<p>Before implementing this task, we can create the resources it needs, namely the "boxShader" and the "box" mesh. The box shader resource can be declared like this:</p>
<div class="fragment"><pre class="fragment">&lt;module name=<span class="stringliteral">&quot;boxShader&quot;</span> version=<span class="stringliteral">&quot;330&quot;</span> source=<span class="stringliteral">&quot;boxShader.glsl&quot;</span>/&gt;
</pre></div><p>Its source code can be inspired from "terrainShader.glsl". We simply need to replace, in the vertex shader, the code accessing the elevationSampler, and computing a continuous level of detail, with a code computing the elevation based on a vec2 uniform containing the minimum and maximum altitudes for the quad (this uniform will need to be set by our drawTerrainBox task):</p>
<div class="fragment"><pre class="fragment">uniform <span class="keyword">struct </span>{
    vec4 offset;
    vec4 camera;
    vec2 blending;
    mat4 localToScreen;
} deformation;

uniform vec2 zminmax;

<span class="preprocessor">#ifdef _VERTEX_</span>
<span class="preprocessor"></span>layout(location=0) in vec3 vertex;

<span class="keywordtype">void</span> main() {
    <span class="keywordtype">float</span> h = mix(zminmax.x, zminmax.y, vertex.z);
    vec3 p = vec3(vertex.xy * deformation.offset.z + deformation.offset.xy, h);
    gl_Position = deformation.localToScreen * vec4(p, 1.0);
}
<span class="preprocessor">#endif</span>
</pre></div><p>The fragment shader is even simpler, we simply need to output a constant color:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#ifdef _FRAGMENT_</span>
<span class="preprocessor"></span>layout(location=0) out vec4 data;
<span class="keywordtype">void</span> main() {
    data = vec4(1.0, 0.0, 0.0, 1.0);
}
<span class="preprocessor">#endif</span>
</pre></div><p>We also need a "box" mesh to be drawn with this shader. We can simply use a wireframe cube, whose bounding box is [0,1]x[0,1]x[0,1]:</p>
<div class="fragment"><pre class="fragment">0 1 0 1 0 1
lines
1
0 3 <span class="keywordtype">float</span> <span class="keyword">false</span>
24
0 0 0
1 0 0
1 0 0
1 1 0
1 1 0
0 1 0
0 1 0
0 0 0
0 0 1
1 0 1
1 0 1
1 1 1
1 1 1
0 1 1
0 1 1
0 0 1
0 0 0
0 0 1
1 0 0
1 0 1
1 1 0
1 1 1
0 1 0
0 1 1
0
</pre></div><p>The "only" thing left is to implement the DrawTerrainBoxTask. For this, start from the source code of the proland::DrawTerrainTask. You can keep exactly the same structure and methods, keep the "getTask" method, remove the code linked to proland::TileSampler and to the "async" mode (including the "findDrawableQuads" method). You can also remove, in the "drawQuad" method, the "order" array, and simply draw the subquads in a fixed order. The important parts to keep are the "t-&gt;deform-&gt;setUniforms" calls (which set the uniforms needed to project vertices on screen, taking deformations into account). Finally you will need a call like</p>
<div class="fragment"><pre class="fragment">p-&gt;getUniform2f(<span class="stringliteral">&quot;zminmax&quot;</span>)-&gt;set(vec2f(q-&gt;zmin, q-&gt;zmax));
</pre></div><p>where "p" is SceneManager::getCurrentProgram() and "q" a terrain quad, in order to set the "zminmax" uniform in the above "boxShader".</p>
<p>You also need to copy and adapt the DrawTerrainTaskResource class, and the two static fields that follow, in order to be able to instantiate your new task from Ork resources.</p>
<h2><a class="anchor" id="sec-exercise4">
Exercise 4</a></h2>
 
<img src="exercise4.png">
 <!--  <div align="center">
<img src="exercise4.png" alt="exercise4.png"/>
</div>
  --> <p>The goal of this exercise is to implement a user defined layer, to draw on each tile its location in the tile cache (see the above image). Starting from the "terrain3" example, what we want to do is to add a layer to the ortho producer, which would draw on top of a "raw" tile, its location in the cache. The first problem is that the ortho producer is a <a class="el" href="classproland_1_1OrthoProducer.html" title="A TileProducer to create texture tiles on GPU from CPU residual tiles.">proland::OrthoProducer</a>, which does not accept layers (unlike the <a class="el" href="classproland_1_1OrthoGPUProducer.html" title="A TileProducer to create texture tiles on GPU from CPU textures tiles.">proland::OrthoGPUProducer</a>). The solution is two use two ortho producers, as in "exercise2". For this (starting from the "terrain3" example): </p>
<ul>
<li>
rename the "groundOrthoGpu" and "groundOrthoGpu1" resources to "backgroundOrthoGpu" and "backgroundOrthoGpu1". </li>
<li>
add a new cache and a new producer, with one layer to copy the tiles from "backgroundOrthoGpu1" (using the "copyShader" that you can copy from "exercise2"), and the other, to be implemented, to draw the location of the tile in its cache: <div class="fragment"><pre class="fragment">&lt;tileCache name=<span class="stringliteral">&quot;groundOrthoGpu&quot;</span> scheduler=<span class="stringliteral">&quot;defaultScheduler&quot;</span>&gt;
    &lt;gpuTileStorage tileSize=<span class="stringliteral">&quot;196&quot;</span> nTiles=<span class="stringliteral">&quot;512&quot;</span>
        internalformat=<span class="stringliteral">&quot;RGB8&quot;</span> format=<span class="stringliteral">&quot;RGB&quot;</span> type=<span class="stringliteral">&quot;UNSIGNED_BYTE&quot;</span> min=<span class="stringliteral">&quot;LINEAR_MIPMAP_LINEAR&quot;</span> mag=<span class="stringliteral">&quot;LINEAR&quot;</span>
        anisotropy=<span class="stringliteral">&quot;16&quot;</span>/&gt;
&lt;/tileCache&gt;
&lt;orthoGpuProducer name=<span class="stringliteral">&quot;groundOrthoGpu1&quot;</span> cache=<span class="stringliteral">&quot;groundOrthoGpu&quot;</span>&gt;
    &lt;textureLayer name=<span class="stringliteral">&quot;background&quot;</span> producer=<span class="stringliteral">&quot;backgroundOrthoGpu1&quot;</span> 
        tileSamplerName=<span class="stringliteral">&quot;sourceSampler&quot;</span> renderProg=<span class="stringliteral">&quot;copyShader;&quot;</span>
        equation=<span class="stringliteral">&quot;ADD&quot;</span> destinationFunction=<span class="stringliteral">&quot;ZERO&quot;</span> sourceFunction=<span class="stringliteral">&quot;ONE&quot;</span>
        equationAlpha=<span class="stringliteral">&quot;ADD&quot;</span> destinationFunctionAlpha=<span class="stringliteral">&quot;ZERO&quot;</span> sourceFunctionAlpha=<span class="stringliteral">&quot;ONE&quot;</span>/&gt;
    &lt;debugOrthoLayer name=<span class="stringliteral">&quot;debug&quot;</span> fontSize=<span class="stringliteral">&quot;24&quot;</span> font=<span class="stringliteral">&quot;basicFont&quot;</span> fontProgram=<span class="stringliteral">&quot;textShader;&quot;</span>/&gt;
&lt;/orthoGpuProducer&gt;
</pre></div>  </li>
</ul>
<p>The "only" thing left is to implement the debugOrthoLayer. For this, start from the source code of the <a class="el" href="classproland_1_1EmptyOrthoLayer.html" title="An OrthoGPUProducer layer that simply fills tiles with a constant color.">proland::EmptyOrthoLayer</a>. To draw text on top of the produced tile, as in the overlays, look at the source code of the ork::ShowInfoTask. You can also reuse this code to adapt the EmptyOrthoLayerResource class. At the end the doCreateTile method of your layer class should look like this:</p>
<div class="fragment"><pre class="fragment">ostringstream os;
os &lt;&lt; dynamic_cast&lt;GPUTileStorage::GPUSlot*&gt;(data)-&gt;l;
ptr&lt;FrameBuffer&gt; fb = SceneManager::getCurrentFrameBuffer();
vec4f vp = fb-&gt;getViewport().cast&lt;<span class="keywordtype">float</span>&gt;();
fb-&gt;setBlend(<span class="keyword">true</span>, ADD, SRC_ALPHA, ONE_MINUS_SRC_ALPHA, ADD, ZERO, ONE);
fontMesh-&gt;clear();
font-&gt;addLine(vp, 2.0f, 2.0f, os.str(), fontHeight, 0xFF0000FF, fontMesh);
fontU-&gt;set(font-&gt;getImage());
fb-&gt;draw(fontProgram, *fontMesh);
fb-&gt;setBlend(<span class="keyword">false</span>);
</pre></div><p>where "os" contains the text to draw (the layer "l" of the "data" slot in its GPUTileStorage).</p>
<h2><a class="anchor" id="sec-exercise5">
Exercise 5</a></h2>
 
<img src="exercise5.png">
 <!--  <div align="center">
<img src="exercise5.png" alt="exercise5.png"/>
</div>
  --> <p>The goal of this exercise is to implement a user defined producer, to produce a terrain texture showing the contour lines of the terrain elevation (see the above image).</p>
<p>Note that, starting from the "terrain3" example, a very simple way to show contour lines, without using any user defined producer, is to insert the following line in the "terrainShader.glsl" file:</p>
<div class="fragment"><pre class="fragment">data = mod(h, 10.0) &lt; 1.0 ? vec4(1.0, 0.0, 0.0, 1.0) : vec4(0.0, 1.0, 0.0, 1.0);
</pre></div><p>between the "float h = ..." and "if (h &lt; 0.1) ... " lines. It is also possible to use a <a class="el" href="classproland_1_1TextureLayer.html" title="An OrthoGPUProducer layer to blend the tiles of two OrthoGPUProducer.">proland::TextureLayer</a> to draw these contour lines directly in the terrain texture tiles. For the purpose of this exercise, however, we propose to implement this with a user defined tile producer.</p>
<p>Starting from the "terrain3" example, we want to replace the "groundOrthoGpu1" producer with a user defined producer:</p>
<div class="fragment"><pre class="fragment">&lt;contourProducer name=<span class="stringliteral">&quot;groundOrthoGpu1&quot;</span> cache=<span class="stringliteral">&quot;groundOrthoGpu&quot;</span> 
    elevations=<span class="stringliteral">&quot;groundElevations1&quot;</span> contourProg=<span class="stringliteral">&quot;contourShader;&quot;</span>/&gt;
</pre></div><p>meaning that this producer will use the "contourProg" shader to transform the elevations produced by the "elevations" producer, in order to generate colors corresponding to contour lines. It is easy to declare the "contourShader":</p>
<div class="fragment"><pre class="fragment">&lt;module name=<span class="stringliteral">&quot;contourShader&quot;</span> version=<span class="stringliteral">&quot;330&quot;</span> source=<span class="stringliteral">&quot;contourShader.glsl&quot;</span>/&gt;
</pre></div><p>and its source code, "contourShader.glsl" is also quite simple (the vertex shader computes uv coordinates, used in the fragment shader to lookup the elevationSampler texture, from which a contour line color is computed with the same code as above):</p>
<div class="fragment"><pre class="fragment">uniform sampler2DArray elevationSampler;
uniform vec4 elevationOSL;

<span class="preprocessor">#ifdef _VERTEX_</span>
<span class="preprocessor"></span>layout(location = 0) in vec4 vertex;
out vec2 uv;
<span class="keywordtype">void</span> main() {
    gl_Position = vertex;
    uv = (vertex.xy * 0.5 + 0.5) * elevationOSL.z + elevationOSL.xy;
}
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="preprocessor">#ifdef _FRAGMENT_</span>
<span class="preprocessor"></span>in vec2 uv;
layout(location = 0) out vec4 data;
<span class="keywordtype">void</span> main() {
    vec4 zfc = textureLod(elevationSampler, vec3(uv, elevationOSL.w), 0.0);
    data = mod(zfc.z, 10.0) &lt; 1.0 ? vec4(1.0, 0.0, 0.0, 1.0) : vec4(0.0, 1.0, 0.0, 1.0);
}
<span class="preprocessor">#endif</span>
</pre></div><p>The "only" thing left is to implement the "contourProducer". For this, start from the source code of <a class="el" href="classproland_1_1NormalProducer.html" title="A TileProducer to generate terrain normals from terrain elevations on GPU.">proland::NormalProducer</a> (which is also a producer using an external elevation producer, except that it uses it to compute normals, while we want contour lines). You can keep the elevationSamplerU and elevationOSLU uniforms, remove the uniforms and code related to normalSamplerU and normalsOSLU (they are used to compute coarse normals from the parent normal tile, but we don't need this in our case), as well as the code related to coordinate transformation (patchCorners, patchVerticals, etc). You can also remove the begin and endCreateTile methods (in this specific case they are only usefull when the producer has layers, which is not the case here). In the startCreateTile, doCreateTile and stopCreateTile methods, remove the code adding a dependency to the parent tile if level is &gt; 0.</p>
<p>You must then add, in the doCreateTile method, the following line:</p>
<div class="fragment"><pre class="fragment">getCache()-&gt;getStorage().cast&lt;GPUTileStorage&gt;()-&gt;notifyChange(gpuData);
</pre></div><p>this notifies the tile storage that the content of a slot has changed, and that mipmaps needs to be recomputed (this line is not present in <a class="el" href="classproland_1_1NormalProducer.html" title="A TileProducer to generate terrain normals from terrain elevations on GPU.">proland::NormalProducer</a>, because this producer is not intended be used with textures having mipmap levels).</p>
<p>You will also need to adapt the offset and scale used to compute the uv coordinates in "contourShader", and passed in the "elevationOSL" uniform. Indeed the normal producer is designed to produce tiles whose size is equal to the size of the elevation tiles (minus borders - e.g., for elevation tiles of size 101=97+4, the normal tiles size is 97). Here, however, we want our producer to produce tiles whose size is not related to the elevation tile size (in the "terrain3" examples, the elevation tiles size is 101=97+4, while the ortho tiles size is 196=192+4). It is quite easy to compute that the necessary scale and offset values are given by the following code:</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> zTileWidth = elevationGpuData-&gt;getWidth();
<span class="keywordtype">float</span> scale = ((zTileWidth - 5.0) / zTileWidth) * (tileWidth / (tileWidth - 4.0));
<span class="keywordtype">float</span> offset = (1.0 - scale) / 2.0;
elevationOSLU-&gt;set(vec4f(offset, offset, scale, elevationGpuData-&gt;l));
</pre></div><p>Indeed, we want the interior border of the texture tile, at uv coordinates 2/B and (B-2)/B (where B is the texture tile size), to match, after a transformation uv * scale + offset, the border of the terrain grid, corresponding to the <em>centers</em> of the elevation texture pixels at coordinates 2.5/A and (A-2.5)/A (where A is the elevation tile size):</p>
 
<center>
<embed src="exercise5.svg" width="80%" type="image/svg+xml"/>
</center>
 <!--  <div align="center">
<img src="exercise5.svg" alt="exercise5.svg"/>
</div>
  --> <p>Solving the two equations 2/B*scale+offset=2.5/A and (B-2)/B*scale+offset=(A-2.5)/A gives the two values for scale and offset shown in the above code. </p>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Sat May 12 09:42:13 2012 for proland by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
