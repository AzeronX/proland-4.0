<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>proland: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li class="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1></h1> 
<div class="mainpage">
<br/><h1>Proland Documentation - Terrain Plugin</h1>
<h2><a class="anchor" id="sec-intro">
Introduction</a></h2>
<p>The Proland terrain plugin provides some producers dedicated to the production of terrain elevation data, as well as generic raster data (this data can represent anything you want, such as reflectances, land cover classes, normal maps, horizon maps, ambient occlusion maps, etc).</p>
<p><a class="el" href="index.html#sec-producers">Terrain plugin producers</a> </p>
<ul>
<li>
<a class="el" href="index.html#sec-residual">Residual producer</a> </li>
<li>
<a class="el" href="index.html#sec-elevation">Elevation producer</a> </li>
<li>
<a class="el" href="index.html#sec-normal">Normal producer</a> </li>
<li>
<a class="el" href="index.html#sec-orthocpu">Ortho CPU producer</a> </li>
<li>
<a class="el" href="index.html#sec-orthogpu">Ortho GPU producer</a> </li>
<li>
<a class="el" href="index.html#sec-ortho">Ortho producer</a> </li>
<li>
<a class="el" href="index.html#sec-example">An example</a> </li>
</ul>
<h2><a class="anchor" id="sec-producers">
Terrain plugin producers</a></h2>
<p>This section presents the predefined producers provided by the Proland terrain plugin. Some producers are dedicated to the production of terrain elevation data, others are designed to produce generic raster data (this data can represent anything you want, such as reflectances, land cover classes, normal maps, horizon maps, ambient occlusion maps, etc).</p>
<h3><a class="anchor" id="sec-residual">
Residual producer</a></h3>
<p>A straightforward way to produce elevation tiles is to load precomputed tiles from disk. This strategy can be implemented with an <a class="el" href="index.html#sec-orthogpu">ortho producer</a>, by interpreting the tile data as elevations. With this strategy each tile can be produced independently. The problem is to produce elevation tiles at higher resolution than the precomputed tiles: if you use a nearest or linear interpolation to generate new elevations, the resulting terrain does not look realistic.</p>
<p>This is why Proland also proposes another strategy, based on a "multiresolution subdivision surface" approach: at each quadtree level except the root, elevation tiles are computed by <em> upsampling</em> the parent tile, and by adding to it <em>residual</em> elevations. Elevation tiles are then produced on the fly, from <em>residual tiles</em>. These residual tiles can be precomputed and stored on disk. They can also be procedural: by using random residuals whose amplitude decreases with the quadtree level, a fractal terrain is obtained through the upsampling and add procedure. An advantage of this approach is that, with a careful choice for the upsampling scheme, the limit surface after many upsampling operations can be smooth  (C<sup>&#8734;</sup>). Hence the terrain can be generated at a higher resolution than what the precomputed residuals describe, and still be smooth, by using null residuals for the missing scales (or a procedural noise, to add fractal details at small scales). Another advantage of this strategy is that the residual tiles can be better compressed than the raw elevations.</p>
<p>The figure below illustrates these relations between the elevation and residual tiles:</p>
 
<center>
<embed src="upsampling.svg" width="80%" type="image/svg+xml"/><br/>
<div class="caption">Relation between elevation and residual
tiles.</div>
</center>
 <!--  <div align="center">
<img src="upsampling.svg" alt="upsampling.svg"/>
</div>
  --> <p>Note that both the elevation and residual tiles have a border (represented with the gray part outside the blue and green squares). This border is equal to two pixels. The root elevation tile is a copy of the root residual tile. The others are obtained by upsampling a quarter of their parent tile, and by adding the corresponding residual tile to the result. More precisely the <em>interior</em> of each tile (i.e., the tile without its border) is obtained by upsampling a quarter of the interior of the parent tile.</p>
<p>The upsampling filter is used to produce elevation tiles, but it is also necessary to (pre)compute the residual tiles. Indeed the residuals needed to obtain a given terrain after upsampling obviously depend on the upsampling filter. This filter is defined on the figure below. It ensures a smooth limit surface:</p>
 
<center>
<embed src="residuals.svg" width="95%" type="image/svg+xml"/><br/>
<div class="caption">The upsampling filter used for producing
elevation tiles.</div>
</center>
 <!--  <div align="center">
<img src="residuals.svg" alt="residuals.svg"/>
</div>
  --> <p>The example on this figure assumes that elevation tiles have 5x5 interior samples, which gives 9x9 samples with the borders. Each sample is supposed to be used to displace the vertices of a grid mesh made of 4x4 quads (represented on the left). In the general case, an elevation tile must have (<em>n</em>+5)x(<em>n</em>+5) samples, including borders, for a grid mesh of <em>n</em>x<em>n</em> quads, where <em>n</em> is even. The lower left corner of the elevation tile on the left, made of 3x3 interior samples, is upsampled into 5x5 new interior samples (9x9 samples with borders) as shown by the colored dots in the center, for a finer mesh still made of 4x4 quads. The new samples are computed as weighted averages of the parent samples, by using the rules on the right, depending on their position: </p>
<ul>
<li>
<p class="startli">a red sample is simply equal to the parent sample at the same position (i.e., the upsampling filter is an interpolating filter, as opposed to an approximating one).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">a green sample is equal to a weighted average of the four neighbor parent samples on its horizontal line, with the -1/16, 9/16, 9/16 and -1/16 weights.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">a blue sample is defined in a similar way, using the four neighbor parent samples on its vertical line.</p>
<p class="endli"></p>
</li>
<li>
finally a yellow sample is defined a weighted average of its sixteen neighbor parent samples, with weights defined by the tensor product of the above weights, i.e., 1/256, -9/256, etc. </li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>to compute the upsampled inner samples we need a one pixel border in the parent tile. To perform a second upsampling step we then need a one pixel border in upsampled tiles. This requires a two pixels border in the parent tile. Hopefully the required border does not grow unbounded. In fact a two pixels border is sufficient to apply recursively any number of upsampling steps.</dd></dl>
<p>The <a class="el" href="classproland_1_1ResidualProducer.html" title="A TileProducer to load elevation residuals from disk to CPU memory.">proland::ResidualProducer</a> class is a producer that can load in CPU memory precomputed residual tiles stored on disk. The residual tiles must be stored in files containing tile "pyramids", one file per pyramid (these files can be produced with proland::preprocessDem and proland::preprocessSphericalDem - see also the "preprocess" example):</p>
 
<center>
<embed src="residualfiles.svg" width="60%" type="image/svg+xml"/>
<br/>
<div class="caption">Storage of residual tiles on files.</div>
</center>
 <!--  <div align="center">
<img src="residualfiles.svg" alt="residualfiles.svg"/>
</div>
  --> <p>There must be at least one file, containing all the residual tiles of the quadtree from the root to some maximum quadtree level. Other files can then be used to provide more resolution at some places. These files also contain a quadtree pyramid, but start from a different tile than the root tile. In the example above the main file contains all the tiles up to (and including) level 5. An additional file contains 5 more levels, starting from the tile (5,28,3) and containing all the sub tiles of this tile, up to level 5+5=10.</p>
<p>Each file must have the following format. The file should start with a header made of 6 32 bits integers and a 32 bits float:</p>
<ul>
<li><code>minLevel</code>: see below.</li>
<li><code>maxLevel</code>: maximum level of the tiles in this file, relatively to the starting tile.</li>
<li><code>tileSize</code>: size of the residual tiles in pixels, including borders, minus 5.</li>
<li><code>rootLevel</code>: level of the starting tile of the pyramid in the absolute quadtree.</li>
<li><code>rootTx</code>: tx coordinate of the starting tile in the absolute quadtree.</li>
<li><code>rootTy</code>: ty coordinate of the starting tile in the absolute quadtree.</li>
<li><code>scale</code>: scaling factor for the residual values in this file.</li>
</ul>
<p>The <code>minLevel</code> must be 0 if <code>rootLevel</code> is not 0. Otherwise it indicates the level of the first tile in the pyramid of size <code>tileSize</code>. The tiles at level <code>minLevel</code>-1, <code> minLevel</code>-2, ..., 0 are supposed to have a size of <code> tileSize</code>/2, <code>tileSize</code>/4, ..., <code>tileSize</code>/2<sup> <code>minLevel</code></sup>. The scale factor is used to convert the residuals, stored as integers, into height differences in some length unit (e.g., meters). A <code>scale</code> of 1 gives a 1 meter precision in altitudes. A <code>scale</code> of 0.1 gives a 0.1 meter precision, and so on.</p>
<p>This header must be followed by an array <code>offsets</code> of 2.<em> ntiles</em> 32 bits offsets (<em>ntiles</em> being equal to the number of tiles in the pyramid, i.e., <code>minLevel</code> + (2<sup>max(<code> maxLevel</code> - <code>minLevel</code>, 0) * 2 + 2</sup> - 1) / 3. These offsets indicate the location of the tiles in the rest of the file, starting from the end of this array. A tile of coordinates (level,tx,ty), <em>relatively to the starting tile</em> (<code> rootLevel</code>,<code>rootTx</code>,<code>rootTy</code>), must be stored between <code>offsets</code>[2<em>i</em>] and <code>offsets</code>[2<em>i</em> +1], where <em>i</em> is the tile index, <em>i</em>=<code>minLevel</code> + tx + ty * 2<sup><em>l</em></sup> + (2<sup>2.<em>l</em></sup> - 1) / 3, with <em>l</em>=max(level - <code>minLevel</code>, 0) (or <em>i</em>=level if level &lt; <code>minLevel</code>). Between these two offsets, the tile must be stored in TIFF format, using 16 bits per pixel, in a single strip.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>tiles with different coordinates can have the same offsets. This is useful to avoid storing many times identical tiles (such as "empty" tiles).</dd></dl>
<h4><a class="anchor" id="sec-resresidual">
Residual producer resource</a></h4>
<p>A residual producer can be loaded with the Ork resource framework, using the following format (see the "terrain4" example for a concrete example):</p>
<div class="fragment"><pre class="fragment">
&lt;residualProducer name="myResidualProducer"
    cache="myCache" file="..." delta="0" scale="1"/&gt;
</pre></div><p>The <code>cache</code> attribute must be the name of a tile cache resource (its tile storage <em>must</em> be a <code> cpuFloatTileStorage</code>, with a tileSize of <code>tileSize+5</code>). The <code>file</code> attribute must be the name of the file containing the residual tiles, in the above format. The optional <code>scale</code> attribute can be used to scale all residuals with some scaling factor. Its default value 1 does not change the residuals. Finally the optional <code>delta</code> attribute can be used to choose a different root level than the "real" root level. Indeed a <code>getTile(level,tx,ty)</code> on a residual producer loads the tile <code>(level+delta,tx,ty)</code> from the residuals file. Hence <code>getTile(0,0,0)</code> loads the tile <code>(delta,0,0)</code>. <code>delta</code> must be between 0 (the default) and <code>minLevel</code>.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>more precisely, if <code>delta</code> is not null, <code>getTile(0,0,0)</code> returns the result of the upsampling and add procedure, applied to the tiles from level 0 to level <code>delta</code> included. Hence the returned tile can be used as a normal "root" tile in an elevation producer (see next section).</dd>
<dd>
if <code>minLevel</code> is not null the first residual tiles do not have the same size as the others. But they are always returned in a (<code>tileSize</code>+5)x(<code>tileSize</code>+5) array, in the lower left corner:</dd></dl>
 
<center>
<embed src="residualtiles.svg" width="80%" type="image/svg+xml"/>
<br/>
<div class="caption">Storage of the residual tiles (in red, with
borders in dark gray) at level 0, 1 and 2 or more, assuming that 
<tt>minLevel</tt>=2 and <tt>tileSize</tt>=8. All tiles are stored in
13x13 arrays (in light gray).</div>
</center>
 <!--  <div align="center">
<img src="residualtiles.svg" alt="residualtiles.svg"/>
</div>
  --> <p>A residual producer can use several tile pyramids stored in several tile files. This can be done as follows:</p>
<div class="fragment"><pre class="fragment">
&lt;residualProducer name="myResidualProducer" cache="myCache"
file="main"&gt;
    &lt;residualProducer cache="myCache" file="region1"/&gt;
    &lt;residualProducer cache="myCache" file="region2"&gt;
        &lt;residualProducer cache="myCache" file="region2-1"/&gt;
        ...
    &lt;/residualProducer&gt;
    ...
    &lt;residualProducer cache="myCache" file="regionN"/&gt;
&lt;/residualProducer&gt;
</pre></div><p>The above producer will use the <code>main</code> file for the first levels of the quadtree, plus the <code>region1</code>, <code>region2</code>, ... <code>regionN</code> files to add more resolution in some regions. This schema is recursive, e.g., <code>region2-1</code> adds even more resolution in a sub region of <code>region2</code>.</p>
<h3><a class="anchor" id="sec-elevation">
Elevation producer</a></h3>
<p>The <a class="el" href="classproland_1_1ElevationProducer.html" title="A TileProducer to create elevation tiles on GPU from CPU residual tiles.">proland::ElevationProducer</a> produces terrain elevations from the residual tiles produced by a residual producer. This GPU producer upsamples parent elevations tiles and adds to them residual tiles, as described in the previous section, all this using shaders on GPU. This producer can have layers, which can be used to modify the elevations after they have been produced with the previous method.</p>
<h4><a class="anchor" id="sec-elevationinput">
Input data</a></h4>
<p>The <a class="el" href="classproland_1_1ElevationProducer.html" title="A TileProducer to create elevation tiles on GPU from CPU residual tiles.">proland::ElevationProducer</a> can be used with several kinds of input. In particular it can be used with or without a residual producer: </p>
<ul>
<li>
<p class="startli">If an elevation producer is used without a residual producer, pseudo random deterministic residuals will be automatically generated. In this case the user must specify the noise amplitude for each quadtree level. This mode can be used to produce random fractal terrains. The "terrain1", "terrain2" and "terrain3" examples illustrate this option.</p>
<p class="endli"></p>
</li>
<li>
If an elevation producer is used with a residual producer, two options are available to generate details at a higher resolution than what the residual producer provides. By default, no details are generated, which results in a smooth surface. The other option is to add fractal details, by specifying a noise amplitude for the quadtree levels for which there are no residual tiles. The "terrain4" example illustrates the first option. </li>
</ul>
<p>In both cases the "upsampling and add" shader, specified by the user, can also be used to get different results from the same inputs. For instance a basic shader can simply use the same noise amplitudes at each point of the terrain. A more complex shader can modulate these amplitudes based on the local altitude, slope or curvature of the terrain. In the first case uniform fratal details are generated everywhere. In the second case the noise can be adapted to the local terrain - for instance to generate more noise in mountains than in plains (these two cases are demonstrated in the "upsampleShader" shader of the "terrain1" and "terrain2" examples).</p>
 
<center>
<img src="elevation-options.jpg" width="80%"><br/>
<div class="caption"><i>Top left</i>: random residuals produce a
fractal terrain. <i>Top right</i>: precomputed residuals from a
residual producer, no added details. <i>Bottom</i>: same terrain with
uniform noise (<i>left</i>) or with non-uniform noise (<i>right</i>).</div>
</center>
 <!--  <div align="center">
<img src="elevation-options.jpg" alt="elevation-options.jpg"/>
</div>
  --> <h4><a class="anchor" id="sec-elevationoutput">
Output data</a></h4>
<p>The produced elevation data has 3 components per pixel, noted (zf,zc,zm) - if no layers are used you don't need to store the third component. The first component is the elevation, as produced by the above upsampling and add procedure. The second component is a <em>coarse elevation</em>, i.e., the elevation of the parent tile at the same point (the goal is to perform an interpolation between zf and zc at rendering, to avoid popping when quads are suddenly subdivided - see sec-quadblend). The third component is a modified elevation. By default it is equal to zf, but the layers can modify its value.</p>
<p>The elevations zf are computed from the unmodified elevations zf of the parent tile, using the upsampling filter described in the previous section. But the coarse elevations zc are computed from the <em>modified</em> elevations zm of the parent tile, using <em>linear</em> interpolation. Indeed zc is intended to give the elevation of the parent <em>mesh</em>, made of planar triangles (hence the linear interpolation). For this we need to know which mesh will be used to render each terrain quad. Indeed elevation tiles can be rendered with meshes of several sizes, provided the elevation tile size is a multiple of the mesh size (note: the mesh diagonal <em>must</em> be oriented from "north west" to "south east"):</p>
 
<center>
<embed src="elevation.svg" width="80%" type="image/svg+xml"/><br/>
<div class="caption">An 9x9 elevation tile (13x13 with borders) can
be used with 8x8, 4x4, 2x2 or 1x1 meshes.</div>
</center>
 <!--  <div align="center">
<img src="elevation.svg" alt="elevation.svg"/>
</div>
  --> <p>Once the mesh size is known we can find which parent samples must be interpolated to compute the coarse elevations zc:</p>
 
<center>
<embed src="elevation2.svg" width="80%" type="image/svg+xml"/><br/>
<div class="caption">Coarse elevations are linearly interpolated from
the modified parent elevations. The parent samples used depend on the
mesh size.</div>
</center>
 <!--  <div align="center">
<img src="elevation2.svg" alt="elevation2.svg"/>
</div>
  --> <dl class="note"><dt><b>Note:</b></dt><dd>Using a mesh size smaller than the elevation tile size can be useful if you want to render the terrain with a "coarse" mesh, but with a high resolution normal map for the terrain shading. For instance you can use for each tile (192+5)x(192+5) elevations, from which you compute (192+1)x(192+1) normals. You can then render the elevations with a grid made of 24x24 quads, but with a (192+1) x(192+1) normal map, which gives 8 times more resolution for normals (the images above were produced with these settings).</dd></dl>
<h4><a class="anchor" id="sec-reselevation">
Elevation producer resource</a></h4>
<p>An elevation producer can be loaded with the Ork resource framework, using the following format:</p>
<div class="fragment"><pre class="fragment">
&lt;elevationProducer name="myElevationProducer"
    cache="myCache" residuals="myResidualProducer"
    upsampleProg="upsampleShader;" blendProg="blendShader;"
    noise="100,50,25,12,6,3,2,1" face="0"
    gridSize="24" flip="false"/&gt;
</pre></div><p>The elevation tiles are produced in the tile cache resource specified by the <code>cache</code> attribute. This cache must have an associated <code>gpuTileStorage</code>. The size of the tiles in this storage define the size of the elevation tiles that will be produced (including borders). The <code>residuals</code> attribute specifies the name of a residual producer (it need not be a <a class="el" href="classproland_1_1ResidualProducer.html" title="A TileProducer to load elevation residuals from disk to CPU memory.">proland::ResidualProducer</a>; any CPU producer producing float values in the same format can be used). This attribute is optional. If it is not present, the <code>noise</code> attribute must be defined (see below).</p>
<dl class="note"><dt><b>Note:</b></dt><dd>the <code>gpuTileStorage</code> that stores the elevation tiles must use 16 or 32 bits float per channel, but it can use less than 4 channels. For instance if you don't use terrain deformations, the fourth component w is not needed. Similarly, if you don't use layers to modify the terrain elevation, the third component is not needed.</dd>
<dd>
The elevation and residual tiles can have different sizes. More precisely the size of the residual tiles must be a multiple of the elevation tile size. For instance if the residual tiles are of size (192+5)x(192+5), the elevation tiles can be (192+5)x(192+5), (96+5) (96+5), (48+5)x(48+5), (24+5)x(24+5), etc (the elevation producer takes care of selecting the right "sub tile", if necessary, of the residual tiles to produce an elevation tile).</dd></dl>
<p>The optional <code>upsampleProg</code> and <code>blendProg</code> attributes specify the shaders to use to perform the "upsample and add" operation, and to blend layers into elevation tiles. Their default values are <code>upsampleShader;</code> and <code>blendShader;</code>. The <code>blendProg</code> program is not necessary if no layers are used. The Proland examples illustrate how these shaders must and can be implemented (in particular the "terrain1", "terrain2" and "graph1" examples).</p>
<p>The optional <code>noise</code> attribute must specify noise amplitudes, one per quadtree level. These amplitudes are used to generate a fractal terrain or to add fractal details to an existing terrain. The optional <code>face</code> attribute specifies to which cube face this producer corresponds, if 6 producers are used to model a planet (see sec-deform). Face numbers must be between 1 and 6 (1 is north pole face, 6 is south pole face - the "terrain2" example shows how the faces must be organized). If the producer name ends with a digit between 1 and 6, then the face attribute is not necessary: it is extracted from the name. This face identifier is used to produce random noise without seams between cube faces.</p>
<p>The <code>gridSize</code> attribute must specify the size in quads of the mesh that will be used to render each terrain quad. This size is needed to correctly compute the coarse elevations zc (see above).</p>
<p>Finally the optional <code>flip</code> attribute indicates if the terrain rendering shader will flip the terrain mesh diagonals dynamically, based on the elevation of the four corners of each "quad" of this mesh, in order to reduce the geometric aliasing of terrain silhouettes:</p>
 
<center>
<img src="elevation-flip.jpg" width="80%"><br/>
<div class="caption">With dynamic diagonal flipping (<i>left</i>)
geometric aliasing is reduced compared to basic rendering (<i>right</i>).</div>
</center>
 <!--  <div align="center">
<img src="elevation-flip.jpg" alt="elevation-flip.jpg"/>
</div>
  --> <p>This option is then set in the <code>upsampleProg</code> shader, which can then compute correct coarse elevations despite this dynamic flipping. The "terrain4" example illustrates how this option can be used (see the modifications in the <code>helloworld.xml</code> file, in the <code>upsampleShader.glsl</code> and <code>terrainShader.glsl</code> code, and in the <code>quad.mesh</code> file).</p>
<h3><a class="anchor" id="sec-normal">
Normal producer</a></h3>
<p>The <a class="el" href="classproland_1_1NormalProducer.html" title="A TileProducer to generate terrain normals from terrain elevations on GPU.">proland::NormalProducer</a> produces terrain normals from the elevation tiles produced by an elevation producer. This GPU producer computes normals with finite differences, using shaders on GPU.</p>
<h4><a class="anchor" id="sec-normalinput">
Input data</a></h4>
<p>The input data of the <a class="el" href="classproland_1_1NormalProducer.html" title="A TileProducer to generate terrain normals from terrain elevations on GPU.">proland::NormalProducer</a> are the elevation tiles produced by an elevation producer. This elevation producer need not be an <a class="el" href="classproland_1_1ElevationProducer.html" title="A TileProducer to create elevation tiles on GPU from CPU residual tiles.">proland::ElevationProducer</a>: any GPU producer producing float elevation values in the same format (3 or 4 components per sample, 2 pixel border, etc.) can be used. The normal producer computes the normals from the modified elevations zm (see <a class="el" href="index.html#sec-elevation">Elevation producer</a>).</p>
<h4><a class="anchor" id="sec-normaloutput">
Output data</a></h4>
<p>The produced normal tiles have four components per pixel noted (nx,ny,ncx,ncy), and have no border (you can store only the first two values if you want). The first components (nx,ny) give the x,y components of the normal at this point (the vertical component z can be computed as the square root of 1-nx*nx-ny*ny). The last components (ncx,ncy) give the x,y components of a <em>coarse normal</em> at this point, i.e., the interpolated normal of the parent <em>mesh</em> at this point (assuming that normals are fetched in a vertex shader and interpolated linearly on each mesh triangle - but it is also possible to use the produced normals as a normal map, i.e., to fetch them in a fragment shader). The goal is to perform an interpolation between the normal and the coarse normal at rendering, to avoid popping when quads are suddenly subdivided - see sec-quadblend. Like for <a class="el" href="index.html#sec-elevationoutput">elevations</a>, the size of the grid that will be used to render each terrain quad must be known to correctly compute of the coarse normals.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>the normals are computed in the tangent frame of the <em>base surface</em> at the center of the tile (i.e. a single tangent frame is used for all the vertices of a tile). By default the base surface is the horizontal plane. If terrain deformations are used, it can be a sphere, a cylinder, etc.</dd></dl>
<h4><a class="anchor" id="sec-resnormal">
Normal producer resource</a></h4>
<p>An normal producer can be loaded with the Ork resource framework, using the following format:</p>
<div class="fragment"><pre class="fragment">
&lt;normalProducer name="myNormalProducer"
    cache="myCache" elevations="myElevationProducer"
    normalProg="normalShader;"
    gridSize="24" deform="none"/&gt;
</pre></div><p>The normal tiles are produced in the tile cache resource specified by the <code>cache</code> attribute. This cache must have an associated <code>gpuTileStorage</code>. The size of the tiles in this storage define the size of the normal tiles that will be produced (recall that they have no border). The <code>elevations</code> attribute specifies the name of the elevation producer (it need not be a <a class="el" href="classproland_1_1ElevationProducer.html" title="A TileProducer to create elevation tiles on GPU from CPU residual tiles.">proland::ElevationProducer</a>) from which the normals will be computed.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>the <code>gpuTileStorage</code> that stores the normal tiles can use integer or float values, and it can use 2 or 4 channels per pixel. With float values the normal coordinates between -1 and 1 are stored as is. With integer coordinates they are mapped to 0..1 first (using (x+1)/2, (y+1)/2). If two channels are used, the coarse normals will simply be discarded. In summary the possible formats are RGBA8, RGBA16F, RGBA32F, IA8, IA16F, IA32F. Also the elevation and normal tile sizes <em>must</em> be equal. For instance, if the elevation tiles are (192+5)x(192+5), the normal tiles must be (192+1)x(192+1).</dd></dl>
<p>The optional <code>normalProg</code> attribute specifies the shader to use to compute the normals from the elevations. Its default values is <code>normalShader;</code>. The Proland examples illustrate how these shaders must and can be implemented (in particular the "terrain1" and "terrain2" examples).</p>
<p>The <code>gridSize</code> attribute must specify the size in quads of the mesh that will be used to render each terrain quad. This size is needed to correctly compute the coarse normals nc (see above).</p>
<p>Finally the optional <code>deform</code> attribute must specify which terrain deformation will be applied to the terrain. Currently only the "none" and "sphere" values are supported, meaning that the terrain will not be deformed, or will be deformed into a sphere (for planet rendering). This value controls the tangent frame in which the normals are computed (see above).</p>
<h3><a class="anchor" id="sec-orthocpu">
Ortho CPU producer</a></h3>
<p>The <a class="el" href="classproland_1_1OrthoCPUProducer.html" title="A TileProducer to load any kind of texture tile from disk to CPU memory.">proland::OrthoCPUProducer</a> class is a producer that can load in CPU memory precomputed tiles stored on disk. The tiles content is not processed by the ortho producers, and can be interpreted as you want: reflectances, land cover classes, normal maps, horizon maps, ambient occlusion maps, etc. Like for <a class="el" href="index.html#sec-residual">residual tiles</a>, the tiles must be stored in files containing tile "pyramids", one file per pyramid (these files can be produced with proland::preprocessOrtho and proland::preprocessSphericalOrtho - see also the "preprocess" example):</p>
 
<center>
<embed src="orthofiles.svg" width="60%" type="image/svg+xml"/><br/>
<div class="caption">Storage of ortho tiles on files.</div>
</center>
 <!--  <div align="center">
<img src="orthofiles.svg" alt="orthofiles.svg"/>
</div>
  --> <p>There must be at least one file, containing all the ortho tiles of the quadtree from the root to some maximum quadtree level. Other files can then be used to provide more resolution at some places. These files also contain a quadtree pyramid, but start from a different tile than the root tile. In the example above the main file contains all the tiles up to (and including) level 5. An additional file contains 5 more levels, starting from the tile (5,28,3) and containing all the sub tiles of this tile, up to level 5+5=10.</p>
<p>Each file must have the following format. The file should start with a header made of 7 32 bits integers:</p>
<ul>
<li><code>maxLevel</code>: maximum level of the tiles in this file, relatively to the starting tile.</li>
<li><code>tileSize</code>: size of the ortho tiles in pixels, without borders.</li>
<li><code>channels</code>: the number of components per pixel, between 1 and 4.</li>
<li><code>rootLevel</code>: level of the starting tile of the pyramid in the absolute quadtree.</li>
<li><code>rootTx</code>: tx coordinate of the starting tile in the absolute quadtree.</li>
<li><code>rootTy</code>: ty coordinate of the starting tile in the absolute quadtree.</li>
<li><code>flags</code>: indicates if tiles have borders and if they are compressed (see below).</li>
</ul>
<p>The <code>flags</code> field is a bitset. If the bit 0 is set it means that tiles are stored in DXT format (otherwise they are stored in TIFF - in uncompressed, deflate, jpeg, etc. format). If the bit 1 is set it means that tiles have a 2 pixels border (otherwise they have no border).</p>
<p>This header must be followed by an array <code>offsets</code> of 2.<em> ntiles</em> 64 bits offsets (<em>ntiles</em> being equal to the number of tiles in the pyramid, i.e., (2<sup><code>maxLevel</code> * 2 + 2</sup> - 1) / 3. These offsets indicate the location of the tiles in the rest of the file, starting from the end of this array. A tile of coordinates (level,tx,ty), <em>relatively to the starting tile</em> (<code>rootLevel</code>,<code>rootTx</code>,<code>rootTy</code>), must be stored between <code>offsets</code>[2<em>i</em>] and <code>offsets</code>[2<em>i</em> +1], where <em>i</em> is the tile index, <em>i</em>=tx + ty * 2<sup><em>level</em></sup> + (2<sup>2.<em>level</em></sup> - 1) / 3. Between these two offsets, the tile must be stored in TIFF or DXT format (as indicated by <code>flags</code> - if TIFF is used each tile must be stored in a single strip).</p>
<h4><a class="anchor" id="sec-resorthocpu">
Ortho CPU producer resource</a></h4>
<p>An ortho CPU producer can be loaded with the Ork resource framework, using the following format:</p>
<div class="fragment"><pre class="fragment">
&lt;orthoCpuProducer name="myOrthoCpuProducer" cache="myCache" file="..."/&gt;
</pre></div><p>The <code>cache</code> attribute must be the name of a tile cache resource. Its tile storage <em>must</em> be a <code> cpuByteTileStorage</code>, with a tileSize of <code>tileSize</code> - or <code>tileSize+4</code> if tiles have a border. The number of channels of this tile storage must also be equal to <code>channels</code>. The <code>file</code> attribute must be the name of the file containing the ortho tiles, in the above format.</p>
<p>An ortho producer can use several tile pyramids stored in several tile files. This can be done as follows:</p>
<div class="fragment"><pre class="fragment">
&lt;orthoCpuProducer name="myOrthoCpuProducer" cache="myCache"
file="main"&gt;
    &lt;orthoCpuProducer cache="myCache" file="region1"/&gt;
    &lt;orthoCpuProducer cache="myCache" file="region2"&gt;
        &lt;orthoCpuProducer cache="myCache" file="region2-1"/&gt;
        ...
    &lt;/orthoCpuProducer&gt;
    ...
    &lt;orthoCpuProducer cache="myCache" file="regionN"/&gt;
&lt;/orthoCpuProducer&gt;
</pre></div><p>The above producer will use the <code>main</code> file for the first levels of the quadtree, plus the <code>region1</code>, <code>region2</code>, ... <code>regionN</code> files to add more resolution in some regions. This schema is recursive, e.g., <code>region2-1</code> adds even more resolution in a sub region of <code>region2</code>. The "graph1" example illustrates how an ortho CPU producer can be used.</p>
<h3><a class="anchor" id="sec-orthogpu">
Ortho GPU producer</a></h3>
<p>The <a class="el" href="classproland_1_1OrthoGPUProducer.html" title="A TileProducer to create texture tiles on GPU from CPU textures tiles.">proland::OrthoGPUProducer</a> class is a producer that can load tiles in GPU memory, from tiles already stored in main memory (such as tiles produced by an ortho CPU producer). By default the tiles are simply copied from CPU to GPU memory. But this producer can also have layers, which can modify this content after it has been copied to GPU (using GPU shaders).</p>
<h4><a class="anchor" id="sec-orthogpulayers">
Predefined layers</a></h4>
<ul>
<li>EmptyOrthoLayer</li>
</ul>
<p>The <a class="el" href="classproland_1_1EmptyOrthoLayer.html" title="An OrthoGPUProducer layer that simply fills tiles with a constant color.">proland::EmptyOrthoLayer</a> is a proland::TileLayer that simply fills a tile with a constant color. It can be used as a first layer to provide a background color for other layers.</p>
<p>A <a class="el" href="classproland_1_1EmptyOrthoLayer.html" title="An OrthoGPUProducer layer that simply fills tiles with a constant color.">proland::EmptyOrthoLayer</a> can be loaded with the Ork resource framework, using the following format: </p>
<div class="fragment"><pre class="fragment">
&lt;emptyOrthoLayer name="background" color="255,255,255"/&gt;
</pre></div><p> The "river1" example illustrates how this layer can be used.</p>
<ul>
<li>TextureLayer</li>
</ul>
<p>The <a class="el" href="classproland_1_1TextureLayer.html" title="An OrthoGPUProducer layer to blend the tiles of two OrthoGPUProducer.">proland::TextureLayer</a> is a proland::TileLayer that draws a quad on top of an ortho texture, using as input a tile produced by another ortho GPU producer (in fact any producer using a GPU tile storage), and a program to transform this external tile before blending it into the tile being produced.</p>
<p>A typical use of this layer is to add layers to an OrthoProducer (see below). Indeed a <a class="el" href="classproland_1_1OrthoProducer.html" title="A TileProducer to create texture tiles on GPU from CPU residual tiles.">proland::OrthoProducer</a> cannot have layers itself. The workaround is to define, in addition to this OrthoProducer, an OrthoGPUProducer with a <a class="el" href="classproland_1_1TextureLayer.html" title="An OrthoGPUProducer layer to blend the tiles of two OrthoGPUProducer.">proland::TextureLayer</a> using as input the OrthoProducer. It is then possible to add other layers to the OrthoGPUProducer. This approach is illustrated in the "exercise2" example.</p>
<p>A <a class="el" href="classproland_1_1TextureLayer.html" title="An OrthoGPUProducer layer to blend the tiles of two OrthoGPUProducer.">proland::TextureLayer</a> can be loaded with the Ork resource framework, using the following format: </p>
<div class="fragment"><pre class="fragment">
&lt;textureLayer name="background" 
    producer="backgroundOrthoGpu1" 
    renderProg="copyShader;" 
    tileSamplerName="sourceSampler" 
    equation="ADD" equationAlpha="ADD" 
    destinationFunction="ZERO" sourceFunction="ONE" 
    destinationFunctionAlpha="ZERO" sourceFunctionAlpha="ONE"/&gt;
</pre></div><p> The <code>producer</code> attribute must contain the name of a tile producer using a GPUTileStorage. It specifies the external tiles that will be composed into the tiles produced by the producer to which this layer belongs. The <code>renderProg</code> attribute specifies the program used to transform the external tiles of <code>producer</code> before they are blended in the produced tiles. The <code>tileSamplerName</code> specifies the name of the uniform in <code>renderProg</code> which is used to access the external tiles (see sec-samplertileglsl). The last attributes specify the blending modes and equations to blend the transformed external tiles into the produced tiles.</p>
<h4><a class="anchor" id="sec-resorthogpu">
Ortho GPU producer resource</a></h4>
<p>An ortho GPU producer can be loaded with the Ork resource framework, using the following format:</p>
<div class="fragment"><pre class="fragment">
&lt;orthoGpuProducer name="myOrthoGpuProducer"
    cache="myCache" backgroundCache="myCache" 
    ortho="myOrthoCpuProducer"/&gt;
</pre></div><p>The <code>cache</code> attribute must be the name of a tile cache resource (its tile storage <em>must</em> be a <code>gpuTileStorage</code>).</p>
<p>The optional <code>backgroundCache</code> attribute must be the name of a tile cache resource (its tile storage <em>must</em> be a <code>gpuTileStorage</code>), which may be the same as <code>cache</code>. This attribute is only necessary if layers are used (see the "graph1" example).</p>
<p>The optional <code>ortho</code> attribute must be the name of the producer that produces the CPU tiles that will be copied to GPU by this ortho GPU producer (it need not be a <a class="el" href="classproland_1_1OrthoCPUProducer.html" title="A TileProducer to load any kind of texture tile from disk to CPU memory.">proland::OrthoCPUProducer</a>). This attribute is necessary if this producer does not have layers. Otherwise, it can be omitted. The tiles will then be produced by the layers alone (the "river1" example illustrates this option. The "graph1" example illustrates the first option).</p>
<dl class="note"><dt><b>Note:</b></dt><dd>the CPU and GPU tile sizes <em>must</em> be equal. For instance if the CPU producer produces tiles of size 192x192, with a 2 pixels border, then the <code>gpuTileStorage</code> of the ortho GPU producer must use GPU tiles of size (192+2*2)x(192+2*2)=196x196. However the <code>gpuTileStorage</code> can use a different number of channels per pixel, and the format of the channels is free (8 bits, 16 bits float, 32 bits float, etc).</dd></dl>
<h3><a class="anchor" id="sec-ortho">
Ortho producer</a></h3>
<p>The <a class="el" href="classproland_1_1OrthoProducer.html" title="A TileProducer to create texture tiles on GPU from CPU residual tiles.">proland::OrthoProducer</a> produces terrain textures from the residual tiles produced by a residual producer (<em>not</em> a <a class="el" href="classproland_1_1ResidualProducer.html" title="A TileProducer to load elevation residuals from disk to CPU memory.">proland::ResidualProducer</a> but, for instance, a <a class="el" href="classproland_1_1OrthoCPUProducer.html" title="A TileProducer to load any kind of texture tile from disk to CPU memory.">proland::OrthoCPUProducer</a> containing precomputed color residuals).</p>
<h4><a class="anchor" id="sec-orthoinput">
Input Data</a></h4>
<p>The <a class="el" href="classproland_1_1OrthoProducer.html" title="A TileProducer to create texture tiles on GPU from CPU residual tiles.">proland::OrthoProducer</a> can be used with several kinds of input. In particular it can be used with or without a residual producer: </p>
<ul>
<li>
<p class="startli">If an ortho producer is used without a residual producer, pseudo random deterministic residuals will be automatically generated. In this case the user must specify the noise amplitude for each quadtree level. This mode can be used to produce random fractal textures. The "terrain3" examples illustrate this option.</p>
<p class="endli"></p>
</li>
<li>
If an ortho producer is used with a residual producer, two options are available to generate details at a higher resolution than what the residual producer provides. By default, no details are generated, which results in a smooth texture. The other option is to add fractal details, by specifying a noise amplitude for the quadtree levels for which there are no residual tiles. </li>
</ul>
<p>In both cases the "upsampling and add" shader, specified by the user, can also be used to get different results from the same inputs, in a similar way as the <a class="el" href="classproland_1_1ElevationProducer.html" title="A TileProducer to create elevation tiles on GPU from CPU residual tiles.">proland::ElevationProducer</a>.</p>
<h4><a class="anchor" id="sec-orthooutput">
Output Data</a></h4>
<p>The ortho producer upsamples parent color tiles and adds to them residual tiles, in a similar way as described in <a class="el" href="index.html#sec-residual">Residual producer</a>, but using a different upsampling filter. This filter is defined below (it is more adapted to color textures, where samples are taken at the center of each texel, whereas the filter for elevation textures was designed for odd number of samples, corresponding to mesh vertices).</p>
 
<center>
<embed src="ortho-residuals.svg" width="95%" type="image/svg+xml"/><br/>
<div class="caption">The upsampling filter used for producing
ortho tiles.</div>
</center>
 <!--  <div align="center">
<img src="ortho-residuals.svg" alt="ortho-residuals.svg"/>
</div>
  --> <p>The example on this figure assumes that texture tiles have 4x4 interior samples, which gives 8x8 samples with the borders. Each sample lies at the center of a texel (represented with black squares). The lower left corner of the color tile on the left, made of 2x2 interior samples, is upsampled into 4x4 new interior samples (8x8 samples with borders) as shown by the colored dots in the center, for a finer texture still made of 4x4 interior texels. The new samples are computed as weighted averages of the parent samples, by using the rules on the right, depending on their position (all weigths are divided by 16, their sum is 1).</p>
<p>The advantage of <a class="el" href="classproland_1_1OrthoProducer.html" title="A TileProducer to create texture tiles on GPU from CPU residual tiles.">proland::OrthoProducer</a> compared to <a class="el" href="classproland_1_1OrthoGPUProducer.html" title="A TileProducer to create texture tiles on GPU from CPU textures tiles.">proland::OrthoGPUProducer</a> is that the limit texture after many upsampling operations is smooth  (C<sup>&#8734;</sup>). Hence the texture can be generated at a higher resolution than what the precomputed residuals describe, and still be smooth, by using null residuals for the missing scales. Another advantage is that this producer supports real-time edition (see sec-edit-ortho). The drawback is that this producer requires more GPU memory than <a class="el" href="classproland_1_1OrthoGPUProducer.html" title="A TileProducer to create texture tiles on GPU from CPU textures tiles.">proland::OrthoGPUProducer</a> (all the ancestors of a tile must also be present on GPU, for better performance).</p>
<h4><a class="anchor" id="sec-ortholayers">
Predefined layers</a></h4>
<p>In general a <a class="el" href="classproland_1_1OrthoProducer.html" title="A TileProducer to create texture tiles on GPU from CPU residual tiles.">proland::OrthoProducer</a> can <b>not</b> have layers. Indeed, any layer would modify the result of the "upsample and add" step above, and these modifications would then be upsampled at the next quadtree levels, producing unwanted results (the reason why the elevation producer can have layers is that an elevation requires a single channel, and that layers modify a separate channel, not used by the upsampling; but this is generally not possible with a texture producer, because a color typically uses 3 or 4 channels. However, with a monochrome OrthoProducer, layers could be used if they modify a separate channel, using the same approach as in ElevationProducer).</p>
<p>The workaround for this is to use a <a class="el" href="classproland_1_1TextureLayer.html" title="An OrthoGPUProducer layer to blend the tiles of two OrthoGPUProducer.">proland::TextureLayer</a> (see above).</p>
<h4><a class="anchor" id="sec-resortho">
Ortho producer resource</a></h4>
<p>An ortho producer can be loaded with the Ork resource framework, using the following format:</p>
<div class="fragment"><pre class="fragment">
&lt;orthoProducer name="myOrthoProducer"
    cache="myCache" residuals="myOrthoCpuProducer" 
    scale="1" maxLevel="16" upsampleProg="upsampleOrthoShader;"
    hsv="true" cnoise="10,20,30" noise="200,180,160,140,120,100"
    face="0"/&gt;
</pre></div><p>The <code>cache</code> attribute must be the name of a tile cache resource (its tile storage <em>must</em> be a <code>gpuTileStorage</code>). The <code>residuals</code> attribute must be the name of the producer that produces the CPU residual tiles that will be used by this ortho GPU producer (it need not be a <a class="el" href="classproland_1_1OrthoCPUProducer.html" title="A TileProducer to load any kind of texture tile from disk to CPU memory.">proland::OrthoCPUProducer</a>). This attribute is optional. If it is not present, the <code>noise</code> attribute must be defined (see below).</p>
<dl class="note"><dt><b>Note:</b></dt><dd>the CPU and GPU tile sizes <em>must</em> be equal. For instance if the residual producer produces tiles of size 192x192, with a 2 pixels border, then the <code>gpuTileStorage</code> of the ortho producer must use GPU tiles of size (192+2*2)x(192+2*2)=196x196. However the <code>gpuTileStorage</code> can use a different number of channels per pixel, and the format of the channels is free (8 bits, 16 bits float, 32 bits float, etc).</dd></dl>
<p>The optional <code>scale</code> attribute is a scaling factor applied to residuals before they are added to the upsampled tiles. The optional <code>maxLevel</code> attribute can be used to set a maximum level for the tiles produced by this producer (by default there is no limit).</p>
<p>The optional <code>upsampleProg</code> attribute specifies the shader to use to perform the "upsample and add" operation. Its default value is <code>upsampleOrthoShader;</code>. The Proland examples illustrate how this shader must and can be implemented (in particular the "terrain3" example).</p>
<p>The optional <code>noise</code> attribute must specify noise amplitudes, one per quadtree level. These amplitudes are used to generate a fractal texture or to add fractal details to an existing texture. The noise color is specified by the <code>cnoise</code> attribute, and the <code>hsv</code> attribute specifies whether this color is in HSV or RGB space.</p>
<p>The optional <code>face</code> attribute specifies to which cube face this producer corresponds, if 6 producers are used to model a planet (see sec-deform). Face numbers must be between 1 and 6 (1 is north pole face, 6 is south pole face - the "terrain2" example shows how the faces must be organized). If the producer name ends with a digit between 1 and 6, then the face attribute is not necessary: it is extracted from the name. This face identifier is used to produce random noise without seams between cube faces.</p>
<h3><a class="anchor" id="sec-example">
An example</a></h3>
<p>A scene with a single terrain described with residual tiles stored in a <code>DEM.dat</code> file, and with texture tiles stored in an <code>ORTHO.dat</code> file, can be described in an Ork archive file as follows:</p>
<p><div class="fragment"><pre class="fragment">&lt;multithreadScheduler name=<span class="stringliteral">&quot;defaultScheduler&quot;</span> nthreads=<span class="stringliteral">&quot;3&quot;</span> fps=<span class="stringliteral">&quot;0&quot;</span>/&gt;

&lt;tileCache name=<span class="stringliteral">&quot;dzCache&quot;</span> scheduler=<span class="stringliteral">&quot;defaultScheduler&quot;</span>&gt;
    &lt;cpuFloatTileStorage tileSize=<span class="stringliteral">&quot;197&quot;</span> channels=<span class="stringliteral">&quot;1&quot;</span> capacity=<span class="stringliteral">&quot;1024&quot;</span>/&gt;
&lt;/tileCache&gt;
&lt;residualProducer name=<span class="stringliteral">&quot;dz&quot;</span> cache=<span class="stringliteral">&quot;dzCache&quot;</span> file=<span class="stringliteral">&quot;DEM.dat&quot;</span>/&gt;

&lt;tileCache name=<span class="stringliteral">&quot;zCache&quot;</span> scheduler=<span class="stringliteral">&quot;defaultScheduler&quot;</span>&gt;
    &lt;gpuTileStorage tileSize=<span class="stringliteral">&quot;29&quot;</span> nTiles=<span class="stringliteral">&quot;1600&quot;</span>
        internalformat=<span class="stringliteral">&quot;RGBA32F&quot;</span> format=<span class="stringliteral">&quot;RGBA&quot;</span> type=<span class="stringliteral">&quot;FLOAT&quot;</span>
        min=<span class="stringliteral">&quot;NEAREST&quot;</span> mag=<span class="stringliteral">&quot;NEAREST&quot;</span>/&gt;
&lt;/tileCache&gt;
&lt;elevationProducer name=<span class="stringliteral">&quot;z&quot;</span> cache=<span class="stringliteral">&quot;zCache&quot;</span> residuals=<span class="stringliteral">&quot;dzCache&quot;</span>/&gt;

&lt;tileCache name=<span class="stringliteral">&quot;nCache&quot;</span> scheduler=<span class="stringliteral">&quot;defaultScheduler&quot;</span>&gt;
    &lt;gpuTileStorage tileSize=<span class="stringliteral">&quot;25&quot;</span> nTiles=<span class="stringliteral">&quot;1600&quot;</span>
        internalformat=<span class="stringliteral">&quot;RGBA32F&quot;</span> format=<span class="stringliteral">&quot;RGBA&quot;</span> type=<span class="stringliteral">&quot;FLOAT&quot;</span>
        min=<span class="stringliteral">&quot;NEAREST&quot;</span> mag=<span class="stringliteral">&quot;NEAREST&quot;</span>/&gt;
&lt;/tileCache&gt;
&lt;normalProducer name=<span class="stringliteral">&quot;n&quot;</span> cache=<span class="stringliteral">&quot;nCache&quot;</span> elevations=<span class="stringliteral">&quot;z&quot;</span>/&gt;
</pre></div></p>
<p>The above resources define a residual producer using the <code>DEM.dat</code> file, with tiles of size (192+5)x(192+5). It is used by an elevation producer using tiles of size (24+5)x(24+5) cached in a storage of 1600 slots, itself used by a normal producer using tiles of the same size but without borders, (24+1) x(24+1), in a storage of 1600 slots.</p>
<p><div class="fragment"><pre class="fragment">
&lt;tileCache name=<span class="stringliteral">&quot;rgbCpuCache&quot;</span> scheduler=<span class="stringliteral">&quot;defaultScheduler&quot;</span>&gt;
    &lt;cpuByteTileStorage tileSize=<span class="stringliteral">&quot;196&quot;</span> channels=<span class="stringliteral">&quot;3&quot;</span> capacity=<span class="stringliteral">&quot;1024&quot;</span>/&gt;
&lt;/tileCache&gt;
&lt;orthoCpuProducer name=<span class="stringliteral">&quot;rgbCpu&quot;</span> cache=<span class="stringliteral">&quot;rgbCpuCache&quot;</span> file=<span class="stringliteral">&quot;ORTHO.dat&quot;</span>/&gt;

&lt;tileCache name=<span class="stringliteral">&quot;rgbGpuCache&quot;</span> scheduler=<span class="stringliteral">&quot;defaultScheduler&quot;</span>&gt;
    &lt;gpuTileStorage tileSize=<span class="stringliteral">&quot;196&quot;</span> nTiles=<span class="stringliteral">&quot;400&quot;</span>
        internalformat=<span class="stringliteral">&quot;RGB8&quot;</span> format=<span class="stringliteral">&quot;RGB&quot;</span> type=<span class="stringliteral">&quot;UNSIGNED_BYTE&quot;</span>
        min=<span class="stringliteral">&quot;LINEAR_MIPMAP_LINEAR&quot;</span> mag=<span class="stringliteral">&quot;LINEAR&quot;</span> minLOD=<span class="stringliteral">&quot;0&quot;</span> maxLOD=<span class="stringliteral">&quot;1&quot;</span>/&gt;
&lt;/tileCache&gt;
&lt;orthoGpuProducer name=<span class="stringliteral">&quot;rgbGpu&quot;</span> cache=<span class="stringliteral">&quot;rgbGpuCache&quot;</span> ortho=<span class="stringliteral">&quot;rgbCpu&quot;</span>/&gt;
</pre></div></p>
<p>The above resources define an ortho CPU producer using the <code>ORTHO.dat</code> file, with tiles of size (192+4)x(192+4). It is used by an ortho GPU producer using tiles of the same size, cached in a storage of 400 slots.</p>
<p><div class="fragment"><pre class="fragment">
&lt;terrainNode name=<span class="stringliteral">&quot;myTerrain&quot;</span> size=<span class="stringliteral">&quot;50000&quot;</span> zmin=<span class="stringliteral">&quot;0&quot;</span> zmax=<span class="stringliteral">&quot;5000&quot;</span>
    splitFactor=<span class="stringliteral">&quot;2&quot;</span> maxLevel=<span class="stringliteral">&quot;16&quot;</span>/&gt;

&lt;node name=<span class="stringliteral">&quot;myTerrainNode&quot;</span> flags=<span class="stringliteral">&quot;object,dynamic&quot;</span>&gt;
    &lt;bounds xmin=<span class="stringliteral">&quot;-50000&quot;</span> ymin=<span class="stringliteral">&quot;-50000&quot;</span> zmin=<span class="stringliteral">&quot;0&quot;</span>
        xmax=<span class="stringliteral">&quot;50000&quot;</span> ymax=<span class="stringliteral">&quot;50000&quot;</span> zmax=<span class="stringliteral">&quot;5000&quot;</span>/&gt;
    &lt;field <span class="keywordtype">id</span>=<span class="stringliteral">&quot;terrain&quot;</span> value=<span class="stringliteral">&quot;myTerrain&quot;</span>/&gt;
    &lt;tileSamplerZ <span class="keywordtype">id</span>=<span class="stringliteral">&quot;z&quot;</span> sampler=<span class="stringliteral">&quot;zSampler&quot;</span> producer=<span class="stringliteral">&quot;z&quot;</span>
        storeInvisible=<span class="stringliteral">&quot;false&quot;</span>/&gt;
    &lt;tileSampler <span class="keywordtype">id</span>=<span class="stringliteral">&quot;n&quot;</span> sampler=<span class="stringliteral">&quot;nSampler&quot;</span> producer=<span class="stringliteral">&quot;n&quot;</span>
        storeInvisible=<span class="stringliteral">&quot;false&quot;</span>/&gt;
    &lt;tileSampler <span class="keywordtype">id</span>=<span class="stringliteral">&quot;rgb&quot;</span> sampler=<span class="stringliteral">&quot;rgbSampler&quot;</span> producer=<span class="stringliteral">&quot;rgb&quot;</span>
        storeParent=<span class="stringliteral">&quot;false&quot;</span> storeInvisible=<span class="stringliteral">&quot;false&quot;</span>/&gt;
    &lt;mesh <span class="keywordtype">id</span>=<span class="stringliteral">&quot;grid&quot;</span> value=<span class="stringliteral">&quot;grid25.mesh&quot;</span>/&gt;
    &lt;method <span class="keywordtype">id</span>=<span class="stringliteral">&quot;update&quot;</span> value=<span class="stringliteral">&quot;updateTerrainMethod&quot;</span>/&gt;
    &lt;method <span class="keywordtype">id</span>=<span class="stringliteral">&quot;draw&quot;</span> value=<span class="stringliteral">&quot;drawTerrainMethod&quot;</span>/&gt;
    &lt;shader <span class="keywordtype">id</span>=<span class="stringliteral">&quot;material&quot;</span> value=<span class="stringliteral">&quot;terrainShader&quot;</span>/&gt;
&lt;/node&gt;
</pre></div></p>
<p>The above resources define a terrain node for a terrain of size 100km x 100km, with elevations between 0 and 5000m, using a split distance factor of 2 to subdivide the terrain quadtree up to level 16 (included). Then a scene node resource is defined for this terrain: it references the terrain via the "terrain" field, and associates with it 3 texture tile samplers to be able to access the elevation, normal and ortho texture tiles from the terrain shader. The terrain scene node also specifies the grid to be used to draw each terrain quad, the method to be used to update the terrain node, the method to draw it, and the shader to be used to draw the terrain.</p>
<p><div class="fragment"><pre class="fragment">
&lt;node name=<span class="stringliteral">&quot;myScene&quot;</span>&gt;
    &lt;node flags=<span class="stringliteral">&quot;camera&quot;</span>&gt;
        &lt;uniformMatrix4f <span class="keywordtype">id</span>=<span class="stringliteral">&quot;cameraToScreen&quot;</span> name=<span class="stringliteral">&quot;cameraToScreen&quot;</span>/&gt;
        &lt;shader <span class="keywordtype">id</span>=<span class="stringliteral">&quot;material&quot;</span> value=<span class="stringliteral">&quot;cameraShader&quot;</span>/&gt;
        &lt;method <span class="keywordtype">id</span>=<span class="stringliteral">&quot;draw&quot;</span> value=<span class="stringliteral">&quot;cameraMethod&quot;</span>/&gt;
    &lt;/node&gt;

    &lt;node name=<span class="stringliteral">&quot;terrain&quot;</span> value=<span class="stringliteral">&quot;myTerrainNode&quot;</span>/&gt;
&lt;/node&gt;
</pre></div></p>
<p>Finally a scene graph is defined, containing a camera and the previous terrain scene node. The <code>updateTerrainMethod</code> resource is defined as follows:</p>
<div class="fragment"><pre class="fragment">&lt;?xml version=<span class="stringliteral">&quot;1.0&quot;</span> ?&gt;
&lt;sequence&gt;
    &lt;updateTerrain name=<span class="stringliteral">&quot;this.terrain&quot;</span>/&gt;
    &lt;updateTileSamplers name=<span class="stringliteral">&quot;this.terrain&quot;</span>/&gt;
&lt;/sequence&gt;
</pre></div><p>in other words it updates the terrain quadtree "this.terrain" and then the texture tile samplers of the scene node to which the method belongs. In our case "this.terrain" refers to the "terrain" field of "myTerrainNode", which itself refers to "myTerrain". And the texture tile samplers are those of the "myTerrainNode" scene node, i.e., the "zSampler", "nSampler" and "rgbSampler" samplers. The <code> drawTerrainMethod</code> can be defined as follows:</p>
<div class="fragment"><pre class="fragment">&lt;?xml version=<span class="stringliteral">&quot;1.0&quot;</span> ?&gt;
&lt;sequence&gt;
    &lt;setProgram&gt;
        &lt;shader name=<span class="stringliteral">&quot;this.material&quot;</span>/&gt;
    &lt;/setProgram&gt;
    &lt;drawTerrain name=<span class="stringliteral">&quot;this.terrain&quot;</span> mesh=<span class="stringliteral">&quot;this.grid&quot;</span> culling=<span class="stringliteral">&quot;true&quot;</span>/&gt;
&lt;/sequence&gt;
</pre></div><p>in order to first set a program using the shader "this.material" (which in our case refers to "myTerrainNode.material", which itself refers to the "terrainShader" shader), before drawing each visible leaf quad using the mesh "this.mesh" (which in our case refers ultimately to "grid25.mesh").</p>
<p>Finally the <code>terrainShader</code> shader should have the following form in order to access the elevation, normal and ortho tiles of the current quad:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &quot;textureTile.glsl&quot;</span>

uniform samplerTile zSampler;
uniform samplerTile nSampler;
uniform samplerTile rgbSampler;

<span class="preprocessor">#ifdef _VERTEX_</span>
<span class="preprocessor"></span>layout(location=0) in vec4 vertex;
out vec2 uv;
<span class="keywordtype">void</span> main() {
    ...
    uv = vertex.xy;
    vec4 z = textureTile(zSampler, uv);
    vec4 n = textureTile(nSampler, uv);
    ...
}
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="preprocessor">#ifdef _FRAGMENT_</span>
<span class="preprocessor"></span>in vec2 uv;
layout(location=0) out vec4 color;
<span class="keywordtype">void</span> main() {
    ...
    vec4 rgba = textureTile(rgbSampler, uv);
    ...
}
<span class="preprocessor">#endif</span>
</pre></div> </div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Sat May 12 09:42:12 2012 for proland by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
